{
  "id": "snapshot_1758933674777_yt616tulr",
  "approvalId": "approval_1758933631242_reiqgofe0",
  "approvalTitle": "Manage Button Models Fix - 设计文档",
  "version": 2,
  "timestamp": "2025-09-27T00:41:14.777Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# 设计文档\r\n\r\n## 概述\r\n\r\n本功能解决Cherry Studio for Houdini中点击\"Manage\"按钮后外部OpenAI兼容服务（如CherryIN）返回404错误的问题。设计专注于拦截和正确处理点击Manage按钮后的模型列表获取操作，通过JavaScript注入和Python后端网络代理来实现。\r\n\r\n## 指导文档对齐\r\n\r\n### 技术标准 (tech.md)\r\n设计遵循现有的JavaScript注入模式和QtWebChannel通信机制，保持与现有Houdini插件架构的一致性。\r\n\r\n### 项目结构 (structure.md)\r\n实现将遵循现有的houdini_plugin/main.py结构，在inject_electron_api()函数中添加新的拦截逻辑。\r\n\r\n## 代码复用分析\r\n\r\n### 现有组件利用\r\n- **JavaScript注入机制**: 复用现有的scripts数组和runJavaScript调用模式\r\n- **QtWebChannel通信**: 利用现有的window.qt.network.fetchProxy和window.qt.network.modelList\r\n- **调试日志系统**: 复用现有的console.log调试输出机制\r\n- **网络代理逻辑**: 利用现有的Python NetworkAPI类\r\n\r\n### 集成点\r\n- **window.api.models.list**: 通过JavaScript注入拦截和增强现有API调用\r\n- **fetchModels函数**: 在ApiService.ts中的现有函数调用链中添加调试和拦截\r\n- **Python NetworkAPI**: 扩展现有的网络代理功能\r\n\r\n## 架构\r\n\r\n设计采用分层拦截架构，在JavaScript前端和Python后端之间建立完整的调用链追踪和错误处理机制。\r\n\r\n### 模块化设计原则\r\n- **单一文件职责**: 每个拦截点处理调用链的一个特定部分\r\n- **组件隔离**: 调试逻辑与业务逻辑分离\r\n- **服务层分离**: JavaScript拦截层、Python代理层、网络请求层清晰分离\r\n- **工具模块化**: 将调试工具和网络代理工具模块化\r\n\r\n```mermaid\r\ngraph TD\r\n    A[Manage按钮点击] --> B[ManageModelsPopup.loadModels]\r\n    B --> C[fetchModels函数]\r\n    C --> D[AiProviderNew.models]\r\n    D --> E[legacyProvider.models]\r\n    E --> F[apiClient.listModels]\r\n    F --> G[window.api.models.list]\r\n    G --> H[JavaScript拦截层]\r\n    H --> I[Python网络代理]\r\n    I --> J[外部API服务]\r\n    \r\n    H --> K[调试日志输出]\r\n    I --> L[多路径回退逻辑]\r\n```\r\n\r\n## 组件和接口\r\n\r\n### JavaScript拦截层\r\n- **目的**: 拦截Manage按钮点击后的模型获取调用链\r\n- **接口**: \r\n  - `window.api.models.list` 拦截和增强\r\n  - `fetchModels` 函数拦截\r\n  - 全局调试日志输出\r\n- **依赖**: 现有的window.qt对象和注入机制\r\n- **复用**: 现有的JavaScript注入脚本数组结构\r\n\r\n### Python网络代理层\r\n- **目的**: 处理外部API请求和错误回退\r\n- **接口**:\r\n  - `NetworkAPI.modelList` 方法\r\n  - `NetworkAPI.fetchProxy` 方法\r\n- **依赖**: urllib网络库和QtWebChannel\r\n- **复用**: 现有的NetworkAPI类结构\r\n\r\n### 调试追踪系统\r\n- **目的**: 提供完整的调用链追踪和错误诊断\r\n- **接口**:\r\n  - console.log调试输出\r\n  - 调用链状态记录\r\n- **依赖**: 浏览器控制台和Python终端输出\r\n- **复用**: 现有的调试日志模式\r\n\r\n## 数据模型\r\n\r\n### 模型获取配置\r\n```\r\nModelListConfig:\r\n- url: string (API端点URL)\r\n- method: string (HTTP方法，默认GET)\r\n- headers: Record<string, string> (请求头)\r\n- body: string | undefined (请求体)\r\n- fallback: { object: 'list', data: [] } (默认响应)\r\n```\r\n\r\n### 调试日志条目\r\n```\r\nDebugLogEntry:\r\n- timestamp: string (时间戳)\r\n- level: 'info' | 'warn' | 'error' (日志级别)\r\n- source: string (来源组件)\r\n- message: string (日志消息)\r\n- data: any (附加数据)\r\n```\r\n\r\n## 错误处理\r\n\r\n### 错误场景\r\n1. **JavaScript注入失败**\r\n   - **处理**: 检查scripts数组结构，确保所有拦截代码在正确位置\r\n   - **用户影响**: 显示\"JavaScript注入失败\"错误信息\r\n\r\n2. **网络请求超时**\r\n   - **处理**: 实现30秒超时机制，返回空模型列表\r\n   - **用户影响**: 显示\"网络请求超时，返回空模型列表\"\r\n\r\n3. **外部API返回404**\r\n   - **处理**: 记录错误但不中断流程，返回空模型列表\r\n   - **用户影响**: 显示\"无法获取模型列表，请检查API配置\"\r\n\r\n4. **Python后端通信失败**\r\n   - **处理**: 回退到原生fetch，记录警告日志\r\n   - **用户影响**: 显示\"使用备用网络请求方式\"\r\n\r\n## 测试策略\r\n\r\n### 单元测试\r\n- JavaScript拦截函数的功能测试\r\n- Python NetworkAPI方法测试\r\n- 调试日志输出验证\r\n\r\n### 集成测试\r\n- 完整的Manage按钮点击到模型列表获取流程测试\r\n- JavaScript注入与Python后端通信测试\r\n- 外部API服务集成测试\r\n\r\n### 端到端测试\r\n- 用户点击Manage按钮的完整场景测试\r\n- 不同外部服务提供商的兼容性测试\r\n- 错误处理和回退机制测试\r\n",
  "fileStats": {
    "size": 4764,
    "lines": 138,
    "lastModified": "2025-09-27T00:40:42.004Z"
  },
  "comments": []
}