我先给出一份“方案B（WebView 内嵌）”的详细可执行方案，只包含步骤与命令，不创建任何代码。你复制后按步骤新建工程，我们随即开始实现。

### 目标
- 在 Houdini 内部用 Qt/PySide 创建对话框，内嵌 `QWebEngineView` 加载 Cherry Studio 的前端（不启用 Electron）。
- 通过 QtWebChannel/HTTP 与前端通信，支持拖拽节点/参数到对话框，并在前端展示与交互。

### 1) 环境与前提
- Houdini 版本与 Qt 版本：
  - 确认你的 Houdini 对应 PySide 版本及 `QtWebEngine` 可用（H19 多为 PySide2/Qt5，H20 起多为 PySide6/Qt6）。
  - 在 Houdini Python shell 测试导入：
    - PySide2: 试 `from PySide2 import QtWebEngineWidgets, QtWebChannel`
    - PySide6: 试 `from PySide6 import QtWebEngineWidgets, QtWebChannel`
- Node.js 环境（建议 18+），包管理器任选 `npm`/`pnpm`/`yarn`（建议 `pnpm`）。
- Git 可用。

### 2) 新建工程目录结构（建议）
- `cherrystudio-for-houdini/`
  - `web/`：Cherry Studio 的 fork 或子模块，内含 web-only 构建脚本
  - `bridge/`：前端“运行时适配层”定义与实现（抽象 Electron 能力，提供 Web 实现）
  - `houdini_plugin/`：Houdini 的 Python 插件与 Qt 对话框（`QWebEngineView`、QtWebChannel、DnD）
  - `scripts/`：自动化脚本（构建、拷贝产物）
  - `docs/`：说明与版本同步策略
  - `tools/`：本地开发辅助（可选）

### 3) 获取 Cherry Studio 源码并准备 web-only 构建
- 获取上游源码（建议 fork 到你自己的 Git 仓库）。
- 在 `web/` 引入你的 fork（建议子模块，便于上游同步）：
```bash
git init
git submodule add https://github.com/<your-fork>/cherry-studio.git web
git submodule update --init --recursive
```
- 在 `web/` 目录安装依赖（任选其一）：
```bash
cd web
pnpm install
# 或 npm ci
```
- 添加 web-only 构建任务（目标：不依赖 Electron，产出纯静态资源）：
  - 在 Cherry Studio 项目中新增 `build:web` 脚本（后续我们实现时会加），输出到 `web/dist-web/`
  - 构建命令占位（先记下，后续我们在项目里补齐）：
```bash
pnpm run build:web
# 或 npm run build:web
```

### 4) 前端“适配层”设计（降低后续升级成本）
- 定义 `platformBridge` 接口（TypeScript），抽象以下能力：
  - 配置读写、剪贴板、文件选择/读写、网络请求增强（如代理）、本地缓存、日志、通知、窗口/焦点事件等
- 提供两套实现：
  - Electron 实现：调用 Electron/Node 能力（上游已有/保留）
  - Web 实现：仅使用浏览器 API + QtWebChannel 暴露的宿主能力
- 通过环境变量或构建入口选择实现（例如 `process.env.RUNTIME = 'web' | 'electron'`）
- 在构建层加“防回归”：
  - 当选择 web 构建时，若业务代码直接引用 Electron/Node API，构建失败（ESLint 规则 + TS 类型守卫）

说明：以上是实现时执行，我们现在仅规划，等你创建工程后再具体落地。

### 5) Houdini 侧对话框与加载方式
- 对话框创建（PySide2/6）：创建 `QDialog` 或 `QMainWindow` 风格的面板，内嵌 `QWebEngineView`
- 资源加载策略（二选一）：
  - 本地静态资源：`QWebEngineView.load(QUrl.fromLocalFile(.../web/dist-web/index.html))`
  - 开发调试服务器：`QWebEngineView.load(QUrl("http://localhost:5173"))`（前端 dev server）
- 集成 QtWebChannel：
  - 在 Python 侧定义一个 `HostBridge` 对象（QObject 派生），暴露方法给前端调用（如读取当前选择节点、写配置等）
  - 在前端启动时通过 `QWebChannel` 与 `HostBridge` 建立连接，并将其注入到你的 `platformBridge` Web 实现

注：当前仅规划，不写代码。等工程创建后我们按此结构实现。

### 6) 拖拽（DnD）设计
- 拖拽入口：在 Qt 容器（承载 `QWebEngineView` 的 `QWidget`）启用 `dragEnterEvent/dropEvent`
- 数据规范（建议）：
  - 节点：`{"type":"node","path":"obj/geo1"}`
  - 参数：`{"type":"parm","node":"obj/geo1","parm":"tx","value":<当前值>,"expr":<可选>}`
- 解析数据：
  - 通过 `mimeData` 读取文本（常见场景可直接从选中节点/参数推断路径）
  - 结合 `hou` API 校验/补全信息
- 推送给前端：
  - 调用 QtWebChannel 暴露的方法（或使用 `runJavaScript`）向前端发送 DnD 事件（由 React/store 接收）
- 兜底：提供一个按钮“从当前选择读取”，避免 DnD 偶发失败时无操作路径

### 7) 自动化与脚本（先规划，后落地）
- 构建前端：
```powershell
# PowerShell 示例
cd web
pnpm install
pnpm run build:web
```
- 拷贝产物到插件资源目录：
```powershell
# 假设产物在 web/dist-web，下述目录仅占位
Copy-Item web\dist-web\* houdini_plugin\public\ -Recurse -Force
```
- 启动调试：
  - 前端调试（热更新）：`pnpm run dev:web`（例如 Vite），Houdini 侧加载 `http://localhost:<port>`
  - 生产模式：加载本地文件 `index.html` 与静态资源

### 8) 版本同步策略（降低升级成本）
- 使用 fork + 子模块：
  - 定期拉取上游 tag（建议只同步稳定版本）
  - 合并后运行 `build:web`，如编译失败，优先在 `platformBridge` Web 实现中补齐
- CI（可选但强烈建议）：
  - 任务：拉取上游指定 tag → 安装依赖 → `build:web` → 将产物复制至 `houdini_plugin/public` → 产出工件
- 锁定依赖：
  - 提交 `pnpm-lock.yaml` 或 `package-lock.json`
  - 将 Electron/Node-only 依赖隔离到 Electron build，仅 web 构建所需依赖对等升级

### 9) 冒烟测试清单（每次更新/构建后）
- 启动与登录（若有）
- 模型列表/对话基础交互可用
- 文本输入、复制粘贴、滚动、快捷键
- 拖放节点/参数进入对话框，前端正确显示数据
- 缩放/DPI、全屏/最小化/切换视图稳定
- 断网/超时处理回退合理

### 10) 风险与规避
- QtWebEngine 版本差异：确认你当前 Houdini 的 Qt 版本支持的 `QWebEngine`
- Electron API 泄漏：通过适配层与构建守卫杜绝
- 资源路径与 Base URL：web 构建需设置静态资源相对路径（避免 `file://` 下资源丢失）
- 输入法/焦点：必要时在 Qt 侧转发焦点/快捷键信号
- 安全：禁用不必要的外部协议、限制本地文件访问（由宿主桥管理）

### 11) 里程碑（建议）
- M1：最小可用（对话框 + QWebEngineView 加载 Hello World + WebChannel 打通）
- M2：集成 Cherry Studio 前端（web-only 构建可加载、基础 UI 正常）
- M3：拖拽与宿主能力（DnD、读取当前选中、配置存取、日志）
- M4：稳定性优化与 CI（DPI、快捷键、版本同步流水线）

你只需先完成以下动作，我们就可以动手实现：
1) 新建空目录 `cherrystudio-for-houdini/` 并初始化 Git。
2) 按第 3 步将 Cherry Studio fork 引入 `web/`（子模块推荐）。
3) 确认你的 Houdini 版本（PySide2 还是 PySide6），以及 `QtWebEngine` 能成功导入。

完成后告诉我你的 Houdini 版本与操作系统（你是 Windows 11），我会据此开始实现 M1（最小可用 Demo），再逐步推进到拖拽与完整适配。