import { g as __toESM } from "./chunk-st2fFX3F.js";
import { b as LanguageSelect_default, c as AntdProvider_default, d as require_lib } from "./LanguageSelect-CNSAjUDp.js";
import { c as init_es, co as LoadingOutlined_default, eA as useTranslation, eX as defaultLanguage, ex as require_jsx_runtime, ez as i18n_default, f5 as loggerService } from "./es-DSPzjfxW.js";
import { ar as fetchChatCompletion, aw as ConversationService, b9 as getAssistantMessage, bc as getUserMessage, c as persistor, cH as MessageContent_default, cp as useTranslate, cs as detectLanguage, d as store_default, d6 as getToastUtilities, dD as ThemeProvider, da as useHotkeys, dw as CodeStyleProvider, e1 as useTimer, e6 as useTopicMessages, f3 as cancelThrottledBlockUpdate, f8 as throttledBlockUpdate, fC as abortCompletion, fL as pauseTrace, fV as useSettings, fk as newMessagesActions, gU as getAssistantById, gV as getDefaultAssistant, gW as getDefaultModel, gX as getDefaultTopic, gY as getDefaultTranslateAssistant, gg as formatErrorMessage, gl as isAbortError, gm as ChunkType, gu as updateOneBlock, gv as upsertManyBlocks, gw as upsertOneBlock, j6 as runAsyncFunction, kA as MessageBlockStatus, kb as isMac, kc as isWin, kd as StoreSyncService_default, ke as IpcChannel, kf as Provider_default, kp as databases_default, kt as createErrorBlock, ku as createMainTextBlock, kw as createThinkingBlock, ky as require_lodash, kz as AssistantMessageStatus, l5 as LanguagesEnum, l6 as UNKNOWN } from "./store-DBcB_6a4.js";
import { b as require_react } from "./react-nO8b1aHv.js";
import "./schemas-Bbbixa2f.js";
import "./types-Db4HyS8d.js";
import { a1 as tooltip_default, an as button_default, bw as dt, w as RefreshIcon_default } from "./ImageViewer-7Uywf6G2.js";
import "./dayjs.min-MfknQfLl.js";
import "./dist-K3A05YNJ.js";
import "./index-browser-CUxx6q5E.js";
import "./stylis-CZpjP453.js";
import "./Component-CqMrb9iV.js";
import "./createLucideIcon-4-34_nUO.js";
import { b as ArrowRightToLine } from "./arrow-right-to-line-DmWYKJ0O.js";
import { b as ArrowRightFromLine } from "./arrow-right-from-line-Wi6JWyk1.js";
import "./arrow-up-right-sEzLqBeK.js";
import "./at-sign--eXL8pnm.js";
import "./bot-0fBsmDoj.js";
import "./camera-CMKwATVm.js";
import "./check-DnDfudbj.js";
import { b as ChevronDown } from "./chevron-down-udgCTh-4.js";
import "./chevron-left-BRrWXxHM.js";
import "./chevron-right-CpVs9O6K.js";
import "./chevron-up-Cvmy7RJF.js";
import "./chevrons-down-up-C1_Lz0Kx.js";
import "./chevrons-up-down-e5mCGkE2.js";
import "./circle-check-big-BsDCI1sC.js";
import "./circle-pause-DL4Ye1q1.js";
import "./circle-play-C1DNAGUM.js";
import { b as CircleQuestionMark } from "./circle-question-mark-CyPOH2yp.js";
import { b as CircleX } from "./circle-x-CHLMAT5w.js";
import "./circle-D6hLwzJy.js";
import "./clock-Dfd8cMP9.js";
import "./code-xml-p0P2d3gX.js";
import "./code-Bo2ttK8-.js";
import { b as Copy } from "./copy-CpEajKZD.js";
import "./corner-down-left-4y_kVVbX.js";
import "./download-C6s0tBBV.js";
import "./door-open-DGH1eVyS.js";
import { b as Droplet } from "./droplet-DGubLLoL.js";
import "./ellipsis-vertical-DqhlPklv.js";
import "./eye-DIWTBjfQ.js";
import "./file-code-D9K12gx6.js";
import "./file-pen-line-kpOIdspx.js";
import "./file-pen-By8L2QiH.js";
import "./file-search-BY-9Tgv4.js";
import "./file-text-DuCPerm4.js";
import "./folder-open-DJrIyqEA.js";
import "./folder-search-iyyc60oU.js";
import "./forward-BHjM25wB.js";
import { b as Globe } from "./globe-Bodx_xd1.js";
import "./image-rK0q7CnN.js";
import "./languages-Cp9yG8eH.js";
import "./lightbulb-CjtBczW8.js";
import "./link-CSOuHNmX.js";
import "./list-checks-CUfYzQPE.js";
import "./list-todo-C6rhsOVD.js";
import "./maximize-2-DsZ40HP0.js";
import "./maximize-B7z4TIpG.js";
import "./menu-Cbt-nPTX.js";
import "./minimize-2-BUEjqZCp.js";
import { b as Minus } from "./minus-CRNbzMeR.js";
import "./notebook-pen-BcNsWWSI.js";
import "./paperclip-BuaQyLAK.js";
import { b as Pause } from "./pause-BzQSLsI4.js";
import "./pencil-ruler-DifyOviw.js";
import "./pencil-BUne13Nu.js";
import { b as Pin } from "./pin-CdQbSaxS.js";
import "./refresh-cw-dH9sR63x.js";
import "./rotate-ccw-BrXZyBhM.js";
import "./save-DgbFeGr5.js";
import "./scan-DLyv51fL.js";
import "./search-CvsnbUB5.js";
import "./send-Dc15IIii.js";
import "./settings-2-Do5QaqO-.js";
import "./shield-check-DYZaVD46.js";
import "./sparkle-BWznofBx.js";
import "./sparkles-BQ3OgBpM.js";
import "./split-7uGqg-1M.js";
import "./square-pen-C-DpNdYM.js";
import "./square-split-horizontal-DfRhwRTD.js";
import "./square-DdtYWO9d.js";
import "./terminal-Cms3CiD1.js";
import "./text-BIe1bJ3v.js";
import "./thumbs-up-8rJrQZVR.js";
import "./trash-B-HK6C4N.js";
import "./triangle-alert-AweCqAsk.js";
import "./upload-BQ52IP1G.js";
import "./wrap-text-K9HtBCai.js";
import "./wrench-DGzYUoOx.js";
import { b as X } from "./x-vNMQm1V5.js";
import "./zoom-in-Bep5HRIm.js";
import "./zoom-out-Cw6bVs6T.js";
import "./es-DuJacPvK.js";
import { b as CopyButton_default, c as slider_default } from "./CopyButton-CnuV0yEg.js";
import "./katex-DjaGwRwv.js";
import "./dist-X8kR-wKB.js";
import "./decode-Dbzf_I5K.js";
import "./preload-helper-T0xubxxH.js";
import "./dist-DBdVgHX_.js";
import "./dist-Cgif874Y.js";
import "./purify.es-CfWAaV4W.js";
import "./internal-CU_JnPDo.js";
import "./dist-CeqfNeaS.js";
import "./edge-O1Hj2Fmm.js";
import "./dist-Qoodeq4a.js";
import "./dist-Bk10HTjR.js";
import "./edge-BRSbLjdy.js";
import { b as require_client } from "./client-D1Q2qHkv.js";
import { b as PersistGate } from "./react-BaMqB5TM.js";
import "./en_US-CaGzDOwj.js";
import { b as DynamicIcon, d as useSelectionAssistant } from "./DynamicIcon-D19P815V.js";
var import_client = /* @__PURE__ */ __toESM(require_client());
await init_es();
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime());
var import_react = /* @__PURE__ */ __toESM(require_react());
var import_lib = /* @__PURE__ */ __toESM(require_lib());
var import_lodash = /* @__PURE__ */ __toESM(require_lodash());
const logger$2 = loggerService.withContext("ActionUtils");
const processMessages = async (assistant, topic, promptContent, setAskId, onStream, onFinish, onError) => {
	if (!assistant || !topic) return;
	try {
		const { message: userMessage, blocks: userBlocks } = getUserMessage({
			assistant,
			topic,
			content: promptContent
		});
		setAskId(userMessage.id);
		store_default.dispatch(newMessagesActions.addMessage({
			topicId: topic.id,
			message: userMessage
		}));
		store_default.dispatch(upsertManyBlocks(userBlocks));
		let textBlockId = null;
		let thinkingBlockId = null;
		let thinkingStartTime = null;
		let textBlockContent = "";
		const resolveThinkingDuration = (duration) => {
			if (typeof duration === "number" && Number.isFinite(duration)) return duration;
			if (thinkingStartTime !== null) return Math.max(0, performance.now() - thinkingStartTime);
			return 0;
		};
		const assistantMessage = getAssistantMessage({
			assistant,
			topic
		});
		store_default.dispatch(newMessagesActions.addMessage({
			topicId: topic.id,
			message: assistantMessage
		}));
		let finished = false;
		const newAssistant = (0, import_lodash.cloneDeep)(assistant);
		if (!newAssistant.settings) newAssistant.settings = {};
		newAssistant.settings.streamOutput = true;
		newAssistant.webSearchProviderId = void 0;
		newAssistant.mcpServers = void 0;
		newAssistant.knowledge_bases = void 0;
		const { modelMessages, uiMessages } = await ConversationService.prepareMessagesForModel([userMessage], newAssistant);
		await fetchChatCompletion({
			messages: modelMessages,
			assistant: newAssistant,
			requestOptions: {},
			uiMessages,
			onChunkReceived: (chunk) => {
				if (finished) return;
				switch (chunk.type) {
					case ChunkType.THINKING_START:
						thinkingStartTime = performance.now();
						if (thinkingBlockId) store_default.dispatch(updateOneBlock({
							id: thinkingBlockId,
							changes: { status: MessageBlockStatus.STREAMING }
						}));
						else {
							const block = createThinkingBlock(assistantMessage.id, "", { status: MessageBlockStatus.STREAMING });
							thinkingBlockId = block.id;
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: block.id } }
							}));
							store_default.dispatch(upsertOneBlock(block));
						}
						break;
					case ChunkType.THINKING_DELTA:
						if (thinkingBlockId) {
							if (thinkingStartTime === null) thinkingStartTime = performance.now();
							const thinkingDuration = resolveThinkingDuration(chunk.thinking_millsec);
							throttledBlockUpdate(thinkingBlockId, {
								content: chunk.text,
								thinking_millsec: thinkingDuration
							});
						}
						onStream();
						break;
					case ChunkType.THINKING_COMPLETE:
						if (thinkingBlockId) {
							const thinkingDuration = resolveThinkingDuration(chunk.thinking_millsec);
							cancelThrottledBlockUpdate(thinkingBlockId);
							store_default.dispatch(updateOneBlock({
								id: thinkingBlockId,
								changes: {
									content: chunk.text,
									status: MessageBlockStatus.SUCCESS,
									thinking_millsec: thinkingDuration
								}
							}));
							thinkingBlockId = null;
						}
						thinkingStartTime = null;
						break;
					case ChunkType.TEXT_START:
						if (textBlockId) store_default.dispatch(updateOneBlock({
							id: textBlockId,
							changes: { status: MessageBlockStatus.STREAMING }
						}));
						else {
							const block = createMainTextBlock(assistantMessage.id, "", { status: MessageBlockStatus.STREAMING });
							textBlockId = block.id;
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: block.id } }
							}));
							store_default.dispatch(upsertOneBlock(block));
						}
						break;
					case ChunkType.TEXT_DELTA:
						if (textBlockId) throttledBlockUpdate(textBlockId, { content: chunk.text });
						onStream();
						textBlockContent = chunk.text;
						break;
					case ChunkType.TEXT_COMPLETE:
						if (textBlockId) {
							cancelThrottledBlockUpdate(textBlockId);
							store_default.dispatch(updateOneBlock({
								id: textBlockId,
								changes: {
									content: chunk.text,
									status: MessageBlockStatus.SUCCESS
								}
							}));
							onFinish(chunk.text);
							textBlockContent = chunk.text;
							textBlockId = null;
						}
						break;
					case ChunkType.BLOCK_COMPLETE:
						store_default.dispatch(newMessagesActions.updateMessage({
							topicId: topic.id,
							messageId: assistantMessage.id,
							updates: { status: AssistantMessageStatus.SUCCESS }
						}));
						break;
					case ChunkType.LLM_RESPONSE_COMPLETE:
						finished = true;
						break;
					case ChunkType.ERROR:
						{
							const blockId = textBlockId || thinkingBlockId;
							thinkingStartTime = null;
							if (blockId) store_default.dispatch(updateOneBlock({
								id: blockId,
								changes: { status: isAbortError(chunk.error) ? MessageBlockStatus.PAUSED : MessageBlockStatus.ERROR }
							}));
							const isErrorTypeAbort = isAbortError(chunk.error);
							let pauseErrorLanguagePlaceholder = "";
							if (isErrorTypeAbort) pauseErrorLanguagePlaceholder = "pause_placeholder";
							const serializableError = {
								name: chunk.error.name,
								message: pauseErrorLanguagePlaceholder || chunk.error.message || formatErrorMessage(chunk.error),
								originalMessage: chunk.error.message,
								stack: chunk.error.stack,
								status: chunk.error.status || chunk.error.code,
								requestId: chunk.error.request_id
							};
							const errorBlock = createErrorBlock(assistantMessage.id, serializableError, { status: isErrorTypeAbort ? MessageBlockStatus.PAUSED : MessageBlockStatus.ERROR });
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: errorBlock.id } }
							}));
							store_default.dispatch(upsertOneBlock(errorBlock));
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { status: isAbortError(chunk.error) ? AssistantMessageStatus.PAUSED : AssistantMessageStatus.ERROR }
							}));
							onFinish(textBlockContent);
						}
						break;
				}
			}
		});
	} catch (err) {
		if (isAbortError(err)) return;
		onError(err instanceof Error ? err : /* @__PURE__ */ new Error("An error occurred"));
		logger$2.error("Error fetching result:", err);
	}
};
const WindowFooter = ({ content = "", loading = false, onPause = void 0, onRegenerate = void 0 }) => {
	const { t } = useTranslation();
	const [isWindowFocus, setIsWindowFocus] = (0, import_react.useState)(true);
	const [isCopyHovered, setIsCopyHovered] = (0, import_react.useState)(false);
	const [isEscHovered, setIsEscHovered] = (0, import_react.useState)(false);
	const [isRegenerateHovered, setIsRegenerateHovered] = (0, import_react.useState)(false);
	const [isContainerHovered, setIsContainerHovered] = (0, import_react.useState)(false);
	const [isShowMe, setIsShowMe] = (0, import_react.useState)(true);
	const hideTimerRef = (0, import_react.useRef)(null);
	const { setTimeoutTimer } = useTimer();
	(0, import_react.useEffect)(() => {
		window.addEventListener("focus", handleWindowFocus);
		window.addEventListener("blur", handleWindowBlur);
		return () => {
			window.removeEventListener("focus", handleWindowFocus);
			window.removeEventListener("blur", handleWindowBlur);
			if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		};
	}, []);
	(0, import_react.useEffect)(() => {
		hideTimerRef.current = setTimeout(() => {
			setIsShowMe(false);
			hideTimerRef.current = null;
		}, 3e3);
		return () => {
			if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		};
	}, []);
	const showMePeriod = () => {
		if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		setIsShowMe(true);
		hideTimerRef.current = setTimeout(() => {
			setIsShowMe(false);
			hideTimerRef.current = null;
		}, 2e3);
	};
	useHotkeys("c", () => {
		showMePeriod();
		handleCopy();
	});
	useHotkeys("r", () => {
		showMePeriod();
		handleRegenerate();
	});
	useHotkeys("esc", () => {
		showMePeriod();
		handleEsc();
	});
	const handleEsc = () => {
		setIsEscHovered(true);
		setTimeoutTimer("handleEsc", () => {
			setIsEscHovered(false);
		}, 200);
		if (loading && onPause) onPause();
		else window.api.selection.closeActionWindow();
	};
	const handleRegenerate = () => {
		setIsRegenerateHovered(true);
		setTimeoutTimer("handleRegenerate_1", () => {
			setIsRegenerateHovered(false);
		}, 200);
		if (loading && onPause) onPause();
		if (onRegenerate) setTimeoutTimer("handleRegenerate_2", () => {
			onRegenerate();
		}, 200);
	};
	const handleCopy = () => {
		if (!content || loading) return;
		navigator.clipboard.writeText(content).then(() => {
			window.toast.success(t("message.copy.success"));
			setIsCopyHovered(true);
			setTimeoutTimer("handleCopy", () => {
				setIsCopyHovered(false);
			}, 200);
		}).catch(() => {
			window.toast.error(t("message.copy.failed"));
		});
	};
	const handleWindowFocus = () => {
		setIsWindowFocus(true);
	};
	const handleWindowBlur = () => {
		setIsWindowFocus(false);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container$2, {
		onMouseEnter: () => setIsContainerHovered(true),
		onMouseLeave: () => setIsContainerHovered(false),
		$isHovered: isContainerHovered,
		$showInitially: isShowMe,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButtonWrapper, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OpButton, {
				onClick: handleEsc,
				$isWindowFocus: isWindowFocus,
				"data-hovered": isEscHovered,
				children: loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(LoadingIconWrapper, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pause, {
					size: 14,
					className: "btn-icon loading-icon",
					style: {
						position: "absolute",
						left: 1,
						top: 1
					}
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
					style: {
						fontSize: 16,
						position: "absolute",
						left: 0,
						top: 0
					},
					className: "btn-icon loading-icon",
					spin: true
				})] }), t("selection.action.window.esc_stop")] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CircleX, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.esc_close")] })
			}),
			onRegenerate && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButton, {
				onClick: handleRegenerate,
				$isWindowFocus: isWindowFocus,
				"data-hovered": isRegenerateHovered,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(RefreshIcon_default, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.r_regenerate")]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButton, {
				onClick: handleCopy,
				$isWindowFocus: isWindowFocus && !!content,
				"data-hovered": isCopyHovered,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.c_copy")]
			})
		] })
	});
};
const Container$2 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`position:absolute;bottom:0;left:50%;transform:translateX(-50%);max-width:480px;min-width:min-content;width:calc(100% - 16px);display:flex;flex-direction:row;align-items:center;justify-content:center;padding:5px 8px;height:32px;backdrop-filter:blur(8px);border-radius:8px;opacity:`, `;transition:all 0.3s ease;&:hover{opacity:1;}`], (props) => props.$showInitially ? 1 : 0);
const OpButtonWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpButtonWrapper" })([`display:flex;flex-direction:row;align-items:center;justify-content:center;color:var(--color-text-secondary);font-size:12px;gap:6px;`]);
const OpButton = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpButton" })([`cursor:pointer;display:flex;flex-direction:row;align-items:center;gap:5px;padding:0 8px;border-radius:4px;background-color:var(--color-background-mute);color:var(--color-text-secondary);height:22px;opacity:`, `;transition:opacity 0.3s ease;transition:color 0.2s ease;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:none;.btn-icon{color:var(--color-text-secondary);}.loading-icon{color:var(--color-error);}&:hover,&[data-hovered='true']{color:var(--color-primary) !important;.btn-icon{color:var(--color-primary) !important;transition:color 0.2s ease;}}`], (props) => props.$isWindowFocus ? 1 : .2);
const LoadingIconWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "LoadingIconWrapper" })([`display:flex;align-items:center;justify-content:center;position:relative;width:16px;height:16px;`]);
var WindowFooter_default = WindowFooter;
await init_es();
const logger$1 = loggerService.withContext("ActionGeneral");
const ActionGeneral = /* @__PURE__ */ import_react.memo(({ action, scrollToBottom }) => {
	const { t } = useTranslation();
	const { language } = useSettings();
	const [error, setError] = (0, import_react.useState)(null);
	const [showOriginal, setShowOriginal] = (0, import_react.useState)(false);
	const [isContented, setIsContented] = (0, import_react.useState)(false);
	const [isLoading, setIsLoading] = (0, import_react.useState)(true);
	const [contentToCopy, setContentToCopy] = (0, import_react.useState)("");
	const initialized = (0, import_react.useRef)(false);
	const assistantRef = (0, import_react.useRef)(null);
	const topicRef = (0, import_react.useRef)(null);
	const promptContentRef = (0, import_react.useRef)("");
	const askId = (0, import_react.useRef)("");
	(0, import_react.useEffect)(() => {
		if (initialized.current) return;
		initialized.current = true;
		const currentAssistant = action.assistantId ? getAssistantById(action.assistantId) || getDefaultAssistant() : getDefaultAssistant();
		assistantRef.current = {
			...currentAssistant,
			model: currentAssistant.model || getDefaultModel()
		};
		topicRef.current = getDefaultTopic(currentAssistant.id);
		let userContent = "";
		switch (action.id) {
			case "summary":
				userContent = `请总结下面的内容。要求：使用 ${language} 语言进行回复；请不要包含对本提示词的任何解释，直接给出回复： \n\n` + action.selectedText;
				break;
			case "explain":
				userContent = `请解释下面的内容。要求：使用 ${language} 语言进行回复；请不要包含对本提示词的任何解释，直接给出回复： \n\n` + action.selectedText;
				break;
			case "refine":
				userContent = `请对用XML标签<INPUT>包裹的用户输入内容进行优化或润色，并保持原内容的含义和完整性。要求：你的输出应当与用户输入内容的语言相同。；请不要包含对本提示词的任何解释，直接给出回复；请不要输出XML标签，直接输出优化后的内容: \n\n<INPUT>${action.selectedText ?? ""}</INPUT>`;
				break;
			default:
				if (!action.prompt) {
					userContent = action.selectedText || "";
					break;
				}
				if (action.prompt.includes("{{text}}")) {
					userContent = action.prompt.replaceAll("{{text}}", action.selectedText);
					break;
				}
				userContent = action.prompt + "\n\n" + action.selectedText;
		}
		promptContentRef.current = userContent;
	}, [action, language]);
	const fetchResult = (0, import_react.useCallback)(() => {
		const setAskId = (id) => {
			askId.current = id;
		};
		const onStream = () => {
			setIsContented(true);
			scrollToBottom?.();
		};
		const onFinish = (content) => {
			setContentToCopy(content);
			setIsLoading(false);
		};
		const onError = (error$1) => {
			setIsLoading(false);
			setError(error$1.message);
		};
		if (!assistantRef.current || !topicRef.current) return;
		logger$1.debug("Before peocess message", { assistant: assistantRef.current });
		processMessages(assistantRef.current, topicRef.current, promptContentRef.current, setAskId, onStream, onFinish, onError);
	}, [scrollToBottom]);
	(0, import_react.useEffect)(() => {
		fetchResult();
	}, [fetchResult]);
	const allMessages = useTopicMessages(topicRef.current?.id || "");
	const messageContent = (0, import_react.useMemo)(() => {
		const assistantMessages = allMessages.filter((message) => message.role === "assistant");
		const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
		return lastAssistantMessage ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MessageContent_default, { message: lastAssistantMessage }, lastAssistantMessage.id) : null;
	}, [allMessages]);
	const handlePause = () => {
		if (askId.current) {
			abortCompletion(askId.current);
			setIsLoading(false);
		}
		if (topicRef.current?.id) pauseTrace(topicRef.current.id);
	};
	const handleRegenerate = () => {
		setContentToCopy("");
		setIsLoading(true);
		fetchResult();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container$1, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(MenuContainer$1, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalHeader$1, {
				onClick: () => setShowOriginal(!showOriginal),
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: showOriginal ? t("selection.action.window.original_hide") : t("selection.action.window.original_show") }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, {
					size: 14,
					className: showOriginal ? "expanded" : ""
				})]
			}) }),
			showOriginal && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalContent$1, { children: [action.selectedText, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OriginalContentCopyWrapper$1, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CopyButton_default, {
				textToCopy: action.selectedText,
				tooltip: t("selection.action.window.original_copy"),
				size: 12
			}) })] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Result$1, { children: [!isContented && isLoading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
				style: { fontSize: 16 },
				spin: true
			}), messageContent] }),
			error && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorMsg$1, { children: error })
		] }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FooterPadding$1, {}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WindowFooter_default, {
			loading: isLoading,
			onPause: handlePause,
			onRegenerate: handleRegenerate,
			content: contentToCopy
		})
	] });
});
const Container$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;`]);
const Result$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Result" })([`margin-top:4px;width:100%;`]);
const MenuContainer$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "MenuContainer" })([`display:flex;width:100%;flex-direction:row;align-items:center;justify-content:flex-end;`]);
const OriginalHeader$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalHeader" })([`display:flex;align-items:center;justify-content:space-between;cursor:pointer;color:var(--color-text-secondary);font-size:12px;&:hover{color:var(--color-primary);}.lucide{transition:transform 0.2s ease;&.expanded{transform:rotate(180deg);}}`]);
const OriginalContent$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContent" })([`padding:8px;margin-top:8px;margin-bottom:12px;background-color:var(--color-background-soft);border-radius:4px;color:var(--color-text-secondary);font-size:12px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const OriginalContentCopyWrapper$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContentCopyWrapper" })([`display:flex;justify-content:flex-end;`]);
const FooterPadding$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "FooterPadding" })([`min-height:12px;`]);
const ErrorMsg$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "ErrorMsg" })([`color:var(--color-error);background:rgba(255,0,0,0.15);border:1px solid var(--color-error);padding:8px 12px;border-radius:4px;margin-bottom:12px;font-size:13px;word-break:break-all;`]);
var ActionGeneral_default = ActionGeneral;
await init_es();
const logger = loggerService.withContext("ActionTranslate");
const ActionTranslate = ({ action, scrollToBottom }) => {
	const { t } = useTranslation();
	const { translateModelPrompt, language } = useSettings();
	const [targetLanguage, setTargetLanguage] = (0, import_react.useState)(LanguagesEnum.enUS);
	const [alterLanguage, setAlterLanguage] = (0, import_react.useState)(LanguagesEnum.zhCN);
	const [error, setError] = (0, import_react.useState)("");
	const [showOriginal, setShowOriginal] = (0, import_react.useState)(false);
	const [isContented, setIsContented] = (0, import_react.useState)(false);
	const [isLoading, setIsLoading] = (0, import_react.useState)(true);
	const [contentToCopy, setContentToCopy] = (0, import_react.useState)("");
	const { getLanguageByLangcode } = useTranslate();
	const initialized = (0, import_react.useRef)(false);
	const assistantRef = (0, import_react.useRef)(null);
	const topicRef = (0, import_react.useRef)(null);
	const askId = (0, import_react.useRef)("");
	(0, import_react.useEffect)(() => {
		runAsyncFunction(async () => {
			const biDirectionLangPair = await databases_default.settings.get({ id: "translate:bidirectional:pair" });
			let targetLang;
			let alterLang;
			if (!biDirectionLangPair || !biDirectionLangPair.value[0]) {
				const lang = getLanguageByLangcode(language);
				if (lang !== UNKNOWN) targetLang = lang;
				else {
					logger.warn("Fallback to zh-CN");
					targetLang = LanguagesEnum.zhCN;
				}
			} else targetLang = getLanguageByLangcode(biDirectionLangPair.value[0]);
			if (!biDirectionLangPair || !biDirectionLangPair.value[1]) alterLang = LanguagesEnum.enUS;
			else alterLang = getLanguageByLangcode(biDirectionLangPair.value[1]);
			setTargetLanguage(targetLang);
			setAlterLanguage(alterLang);
		});
	}, [getLanguageByLangcode, language]);
	(0, import_react.useEffect)(() => {
		if (initialized.current || !action.selectedText) return;
		initialized.current = true;
		const currentAssistant = getDefaultTranslateAssistant(targetLanguage, action.selectedText);
		assistantRef.current = currentAssistant;
		topicRef.current = getDefaultTopic(currentAssistant.id);
	}, [
		action,
		targetLanguage,
		translateModelPrompt
	]);
	const fetchResult = (0, import_react.useCallback)(async () => {
		if (!assistantRef.current || !topicRef.current || !action.selectedText) return;
		const setAskId = (id) => {
			askId.current = id;
		};
		const onStream = () => {
			setIsContented(true);
			scrollToBottom?.();
		};
		const onFinish = (content) => {
			setContentToCopy(content);
			setIsLoading(false);
		};
		const onError = (error$1) => {
			setIsLoading(false);
			setError(error$1.message);
		};
		setIsLoading(true);
		let sourceLanguageCode;
		try {
			sourceLanguageCode = await detectLanguage(action.selectedText);
		} catch (err) {
			onError(err instanceof Error ? err : /* @__PURE__ */ new Error("An error occurred"));
			logger.error("Error detecting language:", err);
			return;
		}
		let translateLang;
		if (sourceLanguageCode === UNKNOWN.langCode) {
			logger.debug("Unknown source language. Just use target language.");
			translateLang = targetLanguage;
		} else {
			logger.debug("Detected Language: ", { sourceLanguage: sourceLanguageCode });
			if (sourceLanguageCode === targetLanguage.langCode) translateLang = alterLanguage;
			else translateLang = targetLanguage;
		}
		const assistant = getDefaultTranslateAssistant(translateLang, action.selectedText);
		assistantRef.current = assistant;
		processMessages(assistant, topicRef.current, assistant.content, setAskId, onStream, onFinish, onError);
	}, [
		action,
		targetLanguage,
		alterLanguage,
		scrollToBottom
	]);
	(0, import_react.useEffect)(() => {
		fetchResult();
	}, [fetchResult]);
	const allMessages = useTopicMessages(topicRef.current?.id || "");
	const messageContent = (0, import_react.useMemo)(() => {
		const assistantMessages = allMessages.filter((message) => message.role === "assistant");
		const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
		return lastAssistantMessage ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MessageContent_default, { message: lastAssistantMessage }, lastAssistantMessage.id) : null;
	}, [allMessages]);
	const handleChangeLanguage = (targetLanguage$1, alterLanguage$1) => {
		setTargetLanguage(targetLanguage$1);
		setAlterLanguage(alterLanguage$1);
		databases_default.settings.put({
			id: "translate:bidirectional:pair",
			value: [targetLanguage$1.langCode, alterLanguage$1.langCode]
		});
	};
	const handlePause = () => {
		if (askId.current) {
			abortCompletion(askId.current);
			setIsLoading(false);
		}
	};
	const handleRegenerate = () => {
		setContentToCopy("");
		setIsLoading(true);
		fetchResult();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(MenuContainer, { children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.any.language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Globe, {
						size: 16,
						style: { flexShrink: 0 }
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowRightToLine, {
					size: 16,
					color: "var(--color-text-3)",
					style: { margin: "0 2px" }
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.target_language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LanguageSelect_default, {
						value: targetLanguage.langCode,
						style: {
							minWidth: 80,
							maxWidth: 200,
							flex: "auto"
						},
						listHeight: 160,
						title: t("translate.target_language"),
						optionFilterProp: "label",
						onChange: (value) => handleChangeLanguage(getLanguageByLangcode(value), alterLanguage),
						disabled: isLoading
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowRightFromLine, {
					size: 16,
					color: "var(--color-text-3)",
					style: { margin: "0 2px" }
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.alter_language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LanguageSelect_default, {
						value: alterLanguage.langCode,
						style: {
							minWidth: 80,
							maxWidth: 200,
							flex: "auto"
						},
						listHeight: 160,
						title: t("translate.alter_language"),
						optionFilterProp: "label",
						onChange: (value) => handleChangeLanguage(targetLanguage, getLanguageByLangcode(value)),
						disabled: isLoading
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("selection.action.translate.smart_translate_tips"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(QuestionIcon, {
						size: 14,
						style: { marginLeft: 4 }
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Spacer, {}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalHeader, {
					onClick: () => setShowOriginal(!showOriginal),
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: showOriginal ? t("selection.action.window.original_hide") : t("selection.action.window.original_show") }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, {
						size: 14,
						className: showOriginal ? "expanded" : ""
					})]
				})
			] }),
			showOriginal && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalContent, { children: [
				action.selectedText,
				" ",
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OriginalContentCopyWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CopyButton_default, {
					textToCopy: action.selectedText,
					tooltip: t("selection.action.window.original_copy"),
					size: 12
				}) })
			] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Result, { children: [!isContented && isLoading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
				style: { fontSize: 16 },
				spin: true
			}), messageContent] }),
			error && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorMsg, { children: error })
		] }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FooterPadding, {}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WindowFooter_default, {
			loading: isLoading,
			onPause: handlePause,
			onRegenerate: handleRegenerate,
			content: contentToCopy
		})
	] });
};
const Container = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`display:flex;flex-direction:column;align-items:center;flex:1;width:100%;`]);
const Result = /* @__PURE__ */ dt.div.withConfig({ displayName: "Result" })([`margin-top:16px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const MenuContainer = /* @__PURE__ */ dt.div.withConfig({ displayName: "MenuContainer" })([`display:flex;width:100%;flex-direction:row;align-items:center;justify-content:space-between;`]);
const OriginalHeader = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalHeader" })([`display:flex;align-items:center;justify-content:space-between;cursor:pointer;color:var(--color-text-secondary);font-size:12px;padding:4px 0;white-space:nowrap;&:hover{color:var(--color-primary);}.lucide{transition:transform 0.2s ease;&.expanded{transform:rotate(180deg);}}`]);
const OriginalContent = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContent" })([`margin-top:8px;padding:8px;background-color:var(--color-background-soft);border-radius:4px;color:var(--color-text-secondary);font-size:12px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const OriginalContentCopyWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContentCopyWrapper" })([`display:flex;justify-content:flex-end;`]);
const FooterPadding = /* @__PURE__ */ dt.div.withConfig({ displayName: "FooterPadding" })([`min-height:12px;`]);
const ErrorMsg = /* @__PURE__ */ dt.div.withConfig({ displayName: "ErrorMsg" })([`color:var(--color-error);background:rgba(255,0,0,0.15);border:1px solid var(--color-error);padding:8px 12px;border-radius:4px;margin-bottom:12px;font-size:13px;word-break:break-all;`]);
const Spacer = /* @__PURE__ */ dt.div.withConfig({ displayName: "Spacer" })([`flex-grow:0.5;`]);
const QuestionIcon = /* @__PURE__ */ dt(CircleQuestionMark).withConfig({ displayName: "QuestionIcon" })([`cursor:pointer;color:var(--color-text-3);`]);
var ActionTranslate_default = ActionTranslate;
const SelectionActionApp = () => {
	const { language, customCss } = useSettings();
	const { t } = useTranslation();
	const [action, setAction] = (0, import_react.useState)(null);
	const isActionLoaded = (0, import_react.useRef)(false);
	const { isAutoClose, isAutoPin, actionWindowOpacity } = useSelectionAssistant();
	const [isPinned, setIsPinned] = (0, import_react.useState)(isAutoPin);
	const [isWindowFocus, setIsWindowFocus] = (0, import_react.useState)(true);
	const [showOpacitySlider, setShowOpacitySlider] = (0, import_react.useState)(false);
	const [opacity, setOpacity] = (0, import_react.useState)(actionWindowOpacity);
	const shouldCloseWhenBlur = (0, import_react.useRef)(false);
	const contentElementRef = (0, import_react.useRef)(null);
	const isAutoScrollEnabled = (0, import_react.useRef)(true);
	const lastScrollHeight = (0, import_react.useRef)(0);
	(0, import_react.useEffect)(() => {
		const actionListenRemover = window.electron?.ipcRenderer.on(IpcChannel.Selection_UpdateActionData, (_, actionItem) => {
			setAction(actionItem);
			isActionLoaded.current = true;
		});
		window.addEventListener("focus", handleWindowFocus);
		window.addEventListener("blur", handleWindowBlur);
		return () => {
			actionListenRemover();
			window.removeEventListener("focus", handleWindowFocus);
			window.removeEventListener("blur", handleWindowBlur);
		};
	}, []);
	(0, import_react.useEffect)(() => {
		if (isAutoPin) {
			window.api.selection.pinActionWindow(true);
			setIsPinned(true);
		} else if (!isActionLoaded.current) {
			window.api.selection.pinActionWindow(false);
			setIsPinned(false);
		}
	}, [isAutoPin]);
	(0, import_react.useEffect)(() => {
		shouldCloseWhenBlur.current = isAutoClose && !isPinned;
	}, [isAutoClose, isPinned]);
	(0, import_react.useEffect)(() => {
		i18n_default.changeLanguage(language || navigator.language || defaultLanguage);
	}, [language]);
	(0, import_react.useEffect)(() => {
		let customCssElement = document.getElementById("user-defined-custom-css");
		if (customCssElement) customCssElement.remove();
		if (customCss) {
			customCssElement = document.createElement("style");
			customCssElement.id = "user-defined-custom-css";
			customCssElement.textContent = customCss;
			document.head.appendChild(customCssElement);
		}
	}, [customCss]);
	(0, import_react.useEffect)(() => {
		const contentEl = contentElementRef.current;
		if (contentEl) {
			contentEl.addEventListener("scroll", handleUserScroll);
			lastScrollHeight.current = contentEl.scrollHeight;
		}
		return () => {
			if (contentEl) contentEl.removeEventListener("scroll", handleUserScroll);
		};
	}, [action]);
	(0, import_react.useEffect)(() => {
		if (action) document.title = `${action.isBuiltIn ? t(action.name) : action.name} - ${t("selection.name")}`;
	}, [action, t]);
	(0, import_react.useEffect)(() => {
		if (!isActionLoaded.current) setOpacity(actionWindowOpacity);
	}, [actionWindowOpacity]);
	const handleMinimize = () => {
		window.api.selection.minimizeActionWindow();
	};
	const handleClose = () => {
		window.api.selection.closeActionWindow();
	};
	const togglePin = () => {
		setIsPinned(!isPinned);
		window.api.selection.pinActionWindow(!isPinned);
	};
	const handleWindowFocus = () => {
		setIsWindowFocus(true);
	};
	const handleWindowBlur = () => {
		if (shouldCloseWhenBlur.current) {
			handleClose();
			return;
		}
		setIsWindowFocus(false);
	};
	const handleOpacityChange = (value) => {
		setOpacity(value);
	};
	const handleScrollToBottom = (0, import_react.useCallback)(() => {
		if (contentElementRef.current && isAutoScrollEnabled.current) contentElementRef.current.scrollTo({
			top: contentElementRef.current.scrollHeight,
			behavior: "smooth"
		});
	}, []);
	const handleUserScroll = () => {
		if (!contentElementRef.current) return;
		const { scrollTop, scrollHeight, clientHeight } = contentElementRef.current;
		const contentIncreased = scrollHeight > lastScrollHeight.current;
		lastScrollHeight.current = scrollHeight;
		if (contentIncreased && isAutoScrollEnabled.current) return;
		const isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 32;
		if (isAtBottom) isAutoScrollEnabled.current = true;
		else isAutoScrollEnabled.current = false;
	};
	const handleResizeStart = (0, import_react.useCallback)((e, direction) => {
		e.preventDefault();
		e.stopPropagation();
		let lastX = e.screenX;
		let lastY = e.screenY;
		const handleMouseMove = (moveEvent) => {
			const deltaX = moveEvent.screenX - lastX;
			const deltaY = moveEvent.screenY - lastY;
			if (deltaX !== 0 || deltaY !== 0) {
				window.api.selection.resizeActionWindow(deltaX, deltaY, direction);
				lastX = moveEvent.screenX;
				lastY = moveEvent.screenY;
			}
		};
		const handleMouseUp = () => {
			window.removeEventListener("mousemove", handleMouseMove);
			window.removeEventListener("mouseup", handleMouseUp);
		};
		window.addEventListener("mousemove", handleMouseMove);
		window.addEventListener("mouseup", handleMouseUp);
	}, []);
	if (!action) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(WindowFrame, {
		$opacity: opacity / 100,
		children: [
			isWin && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "n",
					onMouseDown: (e) => handleResizeStart(e, "n")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "s",
					onMouseDown: (e) => handleResizeStart(e, "s")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "e",
					onMouseDown: (e) => handleResizeStart(e, "e")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "w",
					onMouseDown: (e) => handleResizeStart(e, "w")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "ne",
					onMouseDown: (e) => handleResizeStart(e, "ne")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "nw",
					onMouseDown: (e) => handleResizeStart(e, "nw")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "se",
					onMouseDown: (e) => handleResizeStart(e, "se")
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResizeHandle, {
					$direction: "sw",
					onMouseDown: (e) => handleResizeStart(e, "sw")
				})
			] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TitleBar, {
				$isWindowFocus: isWindowFocus,
				style: isMac ? { paddingLeft: "70px" } : {},
				children: [
					action.icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TitleBarIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DynamicIcon, {
						name: action.icon,
						size: 16,
						style: { color: "var(--color-text-1)" },
						fallback: () => {}
					}) }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TitleBarCaption, { children: action.isBuiltIn ? t(action.name) : action.name }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TitleBarButtons, { children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
							title: isPinned ? t("selection.action.window.pinned") : t("selection.action.window.pin"),
							placement: "bottom",
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
								type: "text",
								icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pin, {
									size: 14,
									className: isPinned ? "pinned" : ""
								}),
								onClick: togglePin,
								className: isPinned ? "pinned" : ""
							})
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
							title: t("selection.action.window.opacity"),
							placement: "bottom",
							...showOpacitySlider ? { open: false } : {},
							children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
								type: "text",
								icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Droplet, { size: 14 }),
								onClick: () => setShowOpacitySlider(!showOpacitySlider),
								className: showOpacitySlider ? "active" : "",
								style: { paddingBottom: "2px" }
							})
						}),
						showOpacitySlider && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OpacitySlider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(slider_default, {
							vertical: true,
							min: 20,
							max: 100,
							value: opacity,
							onChange: handleOpacityChange,
							onChangeComplete: () => setShowOpacitySlider(false),
							tooltip: { formatter: (value) => `${value}%` }
						}) }),
						!isMac && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
							type: "text",
							icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Minus, { size: 16 }),
							onClick: handleMinimize
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
							type: "text",
							icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, { size: 16 }),
							onClick: handleClose,
							className: "close"
						})] })
					] })
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(MainContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content, {
				ref: contentElementRef,
				children: [action.id == "translate" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionTranslate_default, {
					action,
					scrollToBottom: handleScrollToBottom
				}), action.id != "translate" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionGeneral_default, {
					action,
					scrollToBottom: handleScrollToBottom
				})]
			}) })
		]
	});
};
const WindowFrame = /* @__PURE__ */ dt.div.withConfig({ displayName: "WindowFrame" })([`position:relative;display:flex;flex-direction:column;width:calc(100% - 6px);height:calc(100% - 6px);margin:2px;background-color:var(--color-background);border:1px solid var(--color-border);box-shadow:0px 0px 2px var(--color-text-3);border-radius:8px;overflow:hidden;box-sizing:border-box;opacity:`, `;`], (props) => props.$opacity);
const TitleBar = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBar" })([`display:flex;align-items:center;flex-direction:row;height:32px;padding:0 8px;background-color:`, `;transition:background-color 0.3s ease;-webkit-app-region:drag;`], (props) => props.$isWindowFocus ? "var(--color-background-mute)" : "var(--color-background-soft)");
const TitleBarIcon = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarIcon" })([`display:flex;align-items:center;justify-content:center;margin-left:4px;`]);
const TitleBarCaption = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarCaption" })([`margin-left:8px;font-size:14px;font-weight:400;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--color-text-1);`]);
const TitleBarButtons = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarButtons" })([`display:flex;gap:8px;-webkit-app-region:no-drag;position:relative;.lucide{&.pinned{color:var(--color-primary);}}`]);
const WinButton = /* @__PURE__ */ dt(button_default).withConfig({ displayName: "WinButton" })([`display:flex;align-items:center;justify-content:center;width:24px;height:24px;padding:0;border:none;background:transparent;border-radius:4px;transition:all 0.2s;color:var(--color-icon);.anticon{display:flex;align-items:center;justify-content:center;}svg{stroke-width:2;transition:transform 0.2s ease;}&.pinned{svg{transform:rotate(45deg);}&:hover{background-color:var(--color-primary-mute) !important;}}&.close{&:hover{background-color:var(--color-error) !important;color:var(--color-white) !important;}}&.active{background-color:var(--color-primary-mute) !important;color:var(--color-primary) !important;}&:hover{background-color:var(--color-hover) !important;color:var(--color-icon-white) !important;}`]);
const MainContainer = /* @__PURE__ */ dt.div.withConfig({ displayName: "MainContainer" })([`display:flex;justify-content:center;width:100%;height:100%;overflow:auto;`]);
const Content = /* @__PURE__ */ dt.div.withConfig({ displayName: "Content" })([`display:flex;flex-direction:column;flex:1;padding:16px;overflow:auto;font-size:14px;-webkit-app-region:none;user-select:text;max-width:1280px;`]);
const OpacitySlider = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpacitySlider" })([`position:absolute;left:42px;top:100%;margin-top:8px;background-color:var(--color-background-mute);padding:16px 8px 12px 8px;border-radius:4px;box-shadow:0 2px 4px rgba(0,0,0,0.25);height:120px;align-items:center;justify-content:center;z-index:10000;opacity:1 !important;.ant-slider{height:100%;margin:0;}.ant-slider-rail{background-color:var(--color-border);}.ant-slider-track{background-color:var(--color-primary);}.ant-slider-handle{border-color:var(--color-primary);&:hover{border-color:var(--color-primary);}&.ant-slider-handle-active{border-color:var(--color-primary);box-shadow:0 0 0 2px var(--color-primary-mute);}}`]);
const ResizeHandle = /* @__PURE__ */ dt.div.withConfig({ displayName: "ResizeHandle" })([`position:absolute;-webkit-app-region:no-drag;z-index:10;`, ``], ({ $direction }) => {
	const edgeSize = "6px";
	const cornerSize = "12px";
	switch ($direction) {
		case "n": return `
          top: 0;
          left: ${cornerSize};
          right: ${cornerSize};
          height: ${edgeSize};
          cursor: ns-resize;
        `;
		case "s": return `
          bottom: 0;
          left: ${cornerSize};
          right: ${cornerSize};
          height: ${edgeSize};
          cursor: ns-resize;
        `;
		case "e": return `
          right: 0;
          top: ${cornerSize};
          bottom: ${cornerSize};
          width: ${edgeSize};
          cursor: ew-resize;
        `;
		case "w": return `
          left: 0;
          top: ${cornerSize};
          bottom: ${cornerSize};
          width: ${edgeSize};
          cursor: ew-resize;
        `;
		case "ne": return `
          top: 0;
          right: 0;
          width: ${cornerSize};
          height: ${cornerSize};
          cursor: nesw-resize;
        `;
		case "nw": return `
          top: 0;
          left: 0;
          width: ${cornerSize};
          height: ${cornerSize};
          cursor: nwse-resize;
        `;
		case "se": return `
          bottom: 0;
          right: 0;
          width: ${cornerSize};
          height: ${cornerSize};
          cursor: nwse-resize;
        `;
		case "sw": return `
          bottom: 0;
          left: 0;
          width: ${cornerSize};
          height: ${cornerSize};
          cursor: nesw-resize;
        `;
		default: return "";
	}
});
var SelectionActionApp_default = SelectionActionApp;
loggerService.initWindowSource("SelectionActionWindow");
function initKeyv() {
	window.keyv = new import_lib.default();
	window.keyv.init();
}
initKeyv();
StoreSyncService_default.subscribe();
const App = () => {
	(0, import_react.useEffect)(() => {
		window.toast = getToastUtilities();
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Provider_default, {
		store: store_default,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AntdProvider_default, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeStyleProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PersistGate, {
			loading: null,
			persistor,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectionActionApp_default, {})
		}) }) }) })
	});
};
const root = (0, import_client.createRoot)(document.getElementById("root"));
root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, {}));
