import { g as __toESM } from "./chunk-st2fFX3F.js";
import { b as LanguageSelect_default, c as AntdProvider_default, d as require_lib } from "./LanguageSelect-Dd_HYnN-.js";
import { c as init_es, co as LoadingOutlined_default, eA as useTranslation, eW as defaultLanguage, ex as require_jsx_runtime, ez as i18n_default, f4 as loggerService } from "./es-DJ-MjZIp.js";
import { as as fetchChatCompletion, b7 as getAssistantMessage, ba as getUserMessage, c as persistor, cE as MessageContent_default, cm as useTranslate, cp as detectLanguage, d as store_default, d3 as getToastUtilities, d7 as useHotkeys, dA as CodeStyleProvider, dH as ThemeProvider, e7 as useTimer, er as useTopicMessages, fD as throttledBlockUpdate, fM as abortCompletion, fN as ConversationService, fU as newMessagesActions, fy as cancelThrottledBlockUpdate, g2 as pauseTrace, gT as getAssistantById, gU as getDefaultAssistant, gV as getDefaultModel, gW as getDefaultTopic, gX as getDefaultTranslateAssistant, gc as useSettings, ge as formatErrorMessage, gj as isAbortError, gk as ChunkType, gs as updateOneBlock, gt as upsertManyBlocks, gu as upsertOneBlock, j4 as runAsyncFunction, kA as require_lodash, kB as AssistantMessageStatus, kC as MessageBlockStatus, ke as isMac, kg as StoreSyncService_default, kh as IpcChannel, ki as Provider_default, ks as databases_default, kv as createErrorBlock, kw as createMainTextBlock, ky as createThinkingBlock, l7 as LanguagesEnum, l8 as UNKNOWN } from "./store-BImqdIg8.js";
import { b as require_react } from "./react-nO8b1aHv.js";
import "./schemas-Bbbixa2f.js";
import "./dist-mVY8hbYS.js";
import "./dayjs.min-DvZ-eY4k.js";
import { _ as tooltip_default, al as button_default, bu as dt, u as RefreshIcon_default } from "./ImageViewer-DCU5Kc4k.js";
import "./index-browser-Bv7rcEyC.js";
import "./stylis-nHnh4rAK.js";
import "./Component-C3RSLyEk.js";
import "./createLucideIcon-CjX3bse3.js";
import { b as ArrowRightToLine } from "./arrow-right-to-line-D5XwkIJX.js";
import { b as ArrowRightFromLine } from "./arrow-right-from-line-D3qOCLIV.js";
import "./arrow-up-right-COIRPpMK.js";
import "./at-sign--YYfZ-FB.js";
import "./bot-CifdSbss.js";
import "./camera-BcX5pjI7.js";
import "./check-DbK7nSKc.js";
import { b as ChevronDown } from "./chevron-down-Brbq9ymt.js";
import "./chevron-left-BMY3h1gW.js";
import "./chevron-right-DyczuCUV.js";
import "./chevron-up-DkNnWKcs.js";
import "./chevrons-down-up-DhFjuuAs.js";
import "./chevrons-up-down-DW582Q6t.js";
import "./circle-check-big-BelV71JM.js";
import "./circle-pause-pPU2oCDw.js";
import "./circle-play-Bk6_yK7j.js";
import { b as CircleQuestionMark } from "./circle-question-mark-Co-sWLkc.js";
import { b as CircleX } from "./circle-x-CGkQvnZB.js";
import "./circle-RpaaN9rs.js";
import "./clock-DvpiiPDg.js";
import "./code-xml-CHpVmSVF.js";
import "./code-DYb3ktC8.js";
import { b as Copy } from "./copy-07cSu9Qf.js";
import "./corner-down-left-llzVLRlj.js";
import "./download-BdzTMj7r.js";
import "./door-open-ZnleqaAl.js";
import { b as Droplet } from "./droplet-CBMvTL3w.js";
import "./ellipsis-vertical-BgV55T9N.js";
import "./eye-CAQYhGUw.js";
import "./file-code-D6NPtsNe.js";
import "./file-pen-line-oBbo89r-.js";
import "./file-pen-D1V9XjDZ.js";
import "./file-search-Dv1Y3Bde.js";
import "./file-text-D86T6Z-T.js";
import "./folder-open-BQ_CQeJg.js";
import "./folder-search-C46fULzQ.js";
import "./forward-9R0naNk-.js";
import { b as Globe } from "./globe-BOmmzsYO.js";
import "./image-Cb1GPeDA.js";
import "./languages-u0szbzQA.js";
import "./lightbulb-Dxzcatk0.js";
import "./link-BREHE-Qi.js";
import "./list-checks-HlCM2wd1.js";
import "./list-todo-CMeGmUZa.js";
import "./maximize-2-D25Ca7tf.js";
import "./maximize-CM3v-9vV.js";
import "./menu-YtHp9fAX.js";
import "./minimize-2-Cu_P1Meq.js";
import { b as Minus } from "./minus-CGp5ShcX.js";
import "./notebook-pen-DvwH3DPf.js";
import "./paperclip-C_oY0YLS.js";
import { b as Pause } from "./pause-YjLl1Fdi.js";
import "./pencil-ruler-C7xBOEKX.js";
import "./pencil-CCRxknZf.js";
import { b as Pin } from "./pin-BvIPEkPQ.js";
import "./refresh-cw-DmgBpVEP.js";
import "./rotate-ccw-CERny_rH.js";
import "./save-DAN3e6hP.js";
import "./scan-Ck8acUjb.js";
import "./search-CTXNvKf6.js";
import "./send-DomYY08W.js";
import "./settings-2-L3F6pj2j.js";
import "./shield-check-DCTTApCY.js";
import "./sparkle-BE8gp421.js";
import "./sparkles-brghNVVb.js";
import "./split-DRaBQ2SB.js";
import "./square-pen-_zMAK5qp.js";
import "./square-split-horizontal-BnWO_YOZ.js";
import "./square-MeUKWaAJ.js";
import "./terminal-ieif3HI4.js";
import "./text-CWv5VzCX.js";
import "./thumbs-up-B-ljCbt1.js";
import "./trash-CY1O3oyr.js";
import "./triangle-alert-P49zXNor.js";
import "./upload-7jBQdE46.js";
import "./wrap-text-DEwl7hd7.js";
import "./wrench-cLJMYoQB.js";
import { b as X } from "./x-DjnF7E7q.js";
import "./zoom-in-vDLSd3GZ.js";
import "./zoom-out-DR9Ctul-.js";
import "./es-CbXWavyI.js";
import { b as CopyButton_default, c as slider_default } from "./CopyButton-vT3QbtrP.js";
import "./katex-Cwjminzt.js";
import "./dist-DP9OFaqC.js";
import "./decode-Cifd-L7Q.js";
import "./preload-helper-tKu-GDMy.js";
import "./dist-CMbMCVHL.js";
import "./dist-B56-rEVE.js";
import "./purify.es-t-jsSY2O.js";
import "./module-C7pr-eFE.js";
import "./dist-DVyt3Fm-.js";
import "./internal-DLAXfs79.js";
import "./dist-DGTu5mjS.js";
import "./edge-Cdn2gg5V.js";
import "./edge-B17DljaG.js";
import { b as require_client } from "./client-DEIC2nTH.js";
import { b as PersistGate } from "./react-D7kdYjIp.js";
import "./en_US-D1NQv6f9.js";
import { b as DynamicIcon, d as useSelectionAssistant } from "./DynamicIcon-CpR_JUXM.js";
var import_client = /* @__PURE__ */ __toESM(require_client());
await init_es();
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime());
var import_react = /* @__PURE__ */ __toESM(require_react());
var import_lib = /* @__PURE__ */ __toESM(require_lib());
var import_lodash = /* @__PURE__ */ __toESM(require_lodash());
const logger$2 = loggerService.withContext("ActionUtils");
const processMessages = async (assistant, topic, promptContent, setAskId, onStream, onFinish, onError) => {
	if (!assistant || !topic) return;
	try {
		const { message: userMessage, blocks: userBlocks } = getUserMessage({
			assistant,
			topic,
			content: promptContent
		});
		setAskId(userMessage.id);
		store_default.dispatch(newMessagesActions.addMessage({
			topicId: topic.id,
			message: userMessage
		}));
		store_default.dispatch(upsertManyBlocks(userBlocks));
		let textBlockId = null;
		let thinkingBlockId = null;
		let textBlockContent = "";
		const assistantMessage = getAssistantMessage({
			assistant,
			topic
		});
		store_default.dispatch(newMessagesActions.addMessage({
			topicId: topic.id,
			message: assistantMessage
		}));
		let finished = false;
		const newAssistant = (0, import_lodash.cloneDeep)(assistant);
		if (!newAssistant.settings) newAssistant.settings = {};
		newAssistant.settings.streamOutput = true;
		newAssistant.webSearchProviderId = void 0;
		newAssistant.mcpServers = void 0;
		newAssistant.knowledge_bases = void 0;
		const { modelMessages, uiMessages } = await ConversationService.prepareMessagesForModel([userMessage], newAssistant);
		await fetchChatCompletion({
			messages: modelMessages,
			assistant: newAssistant,
			requestOptions: {},
			uiMessages,
			onChunkReceived: (chunk) => {
				if (finished) return;
				switch (chunk.type) {
					case ChunkType.THINKING_START:
						if (thinkingBlockId) store_default.dispatch(updateOneBlock({
							id: thinkingBlockId,
							changes: { status: MessageBlockStatus.STREAMING }
						}));
						else {
							const block = createThinkingBlock(assistantMessage.id, "", { status: MessageBlockStatus.STREAMING });
							thinkingBlockId = block.id;
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: block.id } }
							}));
							store_default.dispatch(upsertOneBlock(block));
						}
						break;
					case ChunkType.THINKING_DELTA:
						if (thinkingBlockId) throttledBlockUpdate(thinkingBlockId, {
							content: chunk.text,
							thinking_millsec: chunk.thinking_millsec
						});
						onStream();
						break;
					case ChunkType.THINKING_COMPLETE:
						if (thinkingBlockId) {
							cancelThrottledBlockUpdate(thinkingBlockId);
							store_default.dispatch(updateOneBlock({
								id: thinkingBlockId,
								changes: {
									content: chunk.text,
									status: MessageBlockStatus.SUCCESS,
									thinking_millsec: chunk.thinking_millsec
								}
							}));
							thinkingBlockId = null;
						}
						break;
					case ChunkType.TEXT_START:
						if (textBlockId) store_default.dispatch(updateOneBlock({
							id: textBlockId,
							changes: { status: MessageBlockStatus.STREAMING }
						}));
						else {
							const block = createMainTextBlock(assistantMessage.id, "", { status: MessageBlockStatus.STREAMING });
							textBlockId = block.id;
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: block.id } }
							}));
							store_default.dispatch(upsertOneBlock(block));
						}
						break;
					case ChunkType.TEXT_DELTA:
						if (textBlockId) throttledBlockUpdate(textBlockId, { content: chunk.text });
						onStream();
						textBlockContent = chunk.text;
						break;
					case ChunkType.TEXT_COMPLETE:
						if (textBlockId) {
							cancelThrottledBlockUpdate(textBlockId);
							store_default.dispatch(updateOneBlock({
								id: textBlockId,
								changes: {
									content: chunk.text,
									status: MessageBlockStatus.SUCCESS
								}
							}));
							onFinish(chunk.text);
							textBlockContent = chunk.text;
							textBlockId = null;
						}
						break;
					case ChunkType.BLOCK_COMPLETE:
						store_default.dispatch(newMessagesActions.updateMessage({
							topicId: topic.id,
							messageId: assistantMessage.id,
							updates: { status: AssistantMessageStatus.SUCCESS }
						}));
						break;
					case ChunkType.LLM_RESPONSE_COMPLETE:
						finished = true;
						break;
					case ChunkType.ERROR:
						{
							const blockId = textBlockId || thinkingBlockId;
							if (blockId) store_default.dispatch(updateOneBlock({
								id: blockId,
								changes: { status: isAbortError(chunk.error) ? MessageBlockStatus.PAUSED : MessageBlockStatus.ERROR }
							}));
							const isErrorTypeAbort = isAbortError(chunk.error);
							let pauseErrorLanguagePlaceholder = "";
							if (isErrorTypeAbort) pauseErrorLanguagePlaceholder = "pause_placeholder";
							const serializableError = {
								name: chunk.error.name,
								message: pauseErrorLanguagePlaceholder || chunk.error.message || formatErrorMessage(chunk.error),
								originalMessage: chunk.error.message,
								stack: chunk.error.stack,
								status: chunk.error.status || chunk.error.code,
								requestId: chunk.error.request_id
							};
							const errorBlock = createErrorBlock(assistantMessage.id, serializableError, { status: isErrorTypeAbort ? MessageBlockStatus.PAUSED : MessageBlockStatus.ERROR });
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { blockInstruction: { id: errorBlock.id } }
							}));
							store_default.dispatch(upsertOneBlock(errorBlock));
							store_default.dispatch(newMessagesActions.updateMessage({
								topicId: topic.id,
								messageId: assistantMessage.id,
								updates: { status: isAbortError(chunk.error) ? AssistantMessageStatus.PAUSED : AssistantMessageStatus.ERROR }
							}));
							onFinish(textBlockContent);
						}
						break;
				}
			}
		});
	} catch (err) {
		if (isAbortError(err)) return;
		onError(err instanceof Error ? err : /* @__PURE__ */ new Error("An error occurred"));
		logger$2.error("Error fetching result:", err);
	}
};
const WindowFooter = ({ content = "", loading = false, onPause = void 0, onRegenerate = void 0 }) => {
	const { t } = useTranslation();
	const [isWindowFocus, setIsWindowFocus] = (0, import_react.useState)(true);
	const [isCopyHovered, setIsCopyHovered] = (0, import_react.useState)(false);
	const [isEscHovered, setIsEscHovered] = (0, import_react.useState)(false);
	const [isRegenerateHovered, setIsRegenerateHovered] = (0, import_react.useState)(false);
	const [isContainerHovered, setIsContainerHovered] = (0, import_react.useState)(false);
	const [isShowMe, setIsShowMe] = (0, import_react.useState)(true);
	const hideTimerRef = (0, import_react.useRef)(null);
	const { setTimeoutTimer } = useTimer();
	(0, import_react.useEffect)(() => {
		window.addEventListener("focus", handleWindowFocus);
		window.addEventListener("blur", handleWindowBlur);
		return () => {
			window.removeEventListener("focus", handleWindowFocus);
			window.removeEventListener("blur", handleWindowBlur);
			if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		};
	}, []);
	(0, import_react.useEffect)(() => {
		hideTimerRef.current = setTimeout(() => {
			setIsShowMe(false);
			hideTimerRef.current = null;
		}, 3e3);
		return () => {
			if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		};
	}, []);
	const showMePeriod = () => {
		if (hideTimerRef.current) clearTimeout(hideTimerRef.current);
		setIsShowMe(true);
		hideTimerRef.current = setTimeout(() => {
			setIsShowMe(false);
			hideTimerRef.current = null;
		}, 2e3);
	};
	useHotkeys("c", () => {
		showMePeriod();
		handleCopy();
	});
	useHotkeys("r", () => {
		showMePeriod();
		handleRegenerate();
	});
	useHotkeys("esc", () => {
		showMePeriod();
		handleEsc();
	});
	const handleEsc = () => {
		setIsEscHovered(true);
		setTimeoutTimer("handleEsc", () => {
			setIsEscHovered(false);
		}, 200);
		if (loading && onPause) onPause();
		else window.api.selection.closeActionWindow();
	};
	const handleRegenerate = () => {
		setIsRegenerateHovered(true);
		setTimeoutTimer("handleRegenerate_1", () => {
			setIsRegenerateHovered(false);
		}, 200);
		if (loading && onPause) onPause();
		if (onRegenerate) setTimeoutTimer("handleRegenerate_2", () => {
			onRegenerate();
		}, 200);
	};
	const handleCopy = () => {
		if (!content || loading) return;
		navigator.clipboard.writeText(content).then(() => {
			window.toast.success(t("message.copy.success"));
			setIsCopyHovered(true);
			setTimeoutTimer("handleCopy", () => {
				setIsCopyHovered(false);
			}, 200);
		}).catch(() => {
			window.toast.error(t("message.copy.failed"));
		});
	};
	const handleWindowFocus = () => {
		setIsWindowFocus(true);
	};
	const handleWindowBlur = () => {
		setIsWindowFocus(false);
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Container$2, {
		onMouseEnter: () => setIsContainerHovered(true),
		onMouseLeave: () => setIsContainerHovered(false),
		$isHovered: isContainerHovered,
		$showInitially: isShowMe,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButtonWrapper, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OpButton, {
				onClick: handleEsc,
				$isWindowFocus: isWindowFocus,
				"data-hovered": isEscHovered,
				children: loading ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(LoadingIconWrapper, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pause, {
					size: 14,
					className: "btn-icon loading-icon",
					style: {
						position: "absolute",
						left: 1,
						top: 1
					}
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
					style: {
						fontSize: 16,
						position: "absolute",
						left: 0,
						top: 0
					},
					className: "btn-icon loading-icon",
					spin: true
				})] }), t("selection.action.window.esc_stop")] }) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CircleX, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.esc_close")] })
			}),
			onRegenerate && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButton, {
				onClick: handleRegenerate,
				$isWindowFocus: isWindowFocus,
				"data-hovered": isRegenerateHovered,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(RefreshIcon_default, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.r_regenerate")]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OpButton, {
				onClick: handleCopy,
				$isWindowFocus: isWindowFocus && !!content,
				"data-hovered": isCopyHovered,
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Copy, {
					size: 14,
					className: "btn-icon"
				}), t("selection.action.window.c_copy")]
			})
		] })
	});
};
const Container$2 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`position:absolute;bottom:0;left:50%;transform:translateX(-50%);max-width:480px;min-width:min-content;width:calc(100% - 16px);display:flex;flex-direction:row;align-items:center;justify-content:center;padding:5px 8px;height:32px;backdrop-filter:blur(8px);border-radius:8px;opacity:`, `;transition:all 0.3s ease;&:hover{opacity:1;}`], (props) => props.$showInitially ? 1 : 0);
const OpButtonWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpButtonWrapper" })([`display:flex;flex-direction:row;align-items:center;justify-content:center;color:var(--color-text-secondary);font-size:12px;gap:6px;`]);
const OpButton = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpButton" })([`cursor:pointer;display:flex;flex-direction:row;align-items:center;gap:5px;padding:0 8px;border-radius:4px;background-color:var(--color-background-mute);color:var(--color-text-secondary);height:22px;opacity:`, `;transition:opacity 0.3s ease;transition:color 0.2s ease;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;user-select:none;.btn-icon{color:var(--color-text-secondary);}.loading-icon{color:var(--color-error);}&:hover,&[data-hovered='true']{color:var(--color-primary) !important;.btn-icon{color:var(--color-primary) !important;transition:color 0.2s ease;}}`], (props) => props.$isWindowFocus ? 1 : .2);
const LoadingIconWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "LoadingIconWrapper" })([`display:flex;align-items:center;justify-content:center;position:relative;width:16px;height:16px;`]);
var WindowFooter_default = WindowFooter;
await init_es();
const logger$1 = loggerService.withContext("ActionGeneral");
const ActionGeneral = /* @__PURE__ */ import_react.memo(({ action, scrollToBottom }) => {
	const { t } = useTranslation();
	const { language } = useSettings();
	const [error, setError] = (0, import_react.useState)(null);
	const [showOriginal, setShowOriginal] = (0, import_react.useState)(false);
	const [isContented, setIsContented] = (0, import_react.useState)(false);
	const [isLoading, setIsLoading] = (0, import_react.useState)(true);
	const [contentToCopy, setContentToCopy] = (0, import_react.useState)("");
	const initialized = (0, import_react.useRef)(false);
	const assistantRef = (0, import_react.useRef)(null);
	const topicRef = (0, import_react.useRef)(null);
	const promptContentRef = (0, import_react.useRef)("");
	const askId = (0, import_react.useRef)("");
	(0, import_react.useEffect)(() => {
		if (initialized.current) return;
		initialized.current = true;
		const currentAssistant = action.assistantId ? getAssistantById(action.assistantId) || getDefaultAssistant() : getDefaultAssistant();
		assistantRef.current = {
			...currentAssistant,
			model: currentAssistant.model || getDefaultModel()
		};
		topicRef.current = getDefaultTopic(currentAssistant.id);
		let userContent = "";
		switch (action.id) {
			case "summary":
				userContent = `请总结下面的内容。要求：使用 ${language} 语言进行回复；请不要包含对本提示词的任何解释，直接给出回复： \n\n` + action.selectedText;
				break;
			case "explain":
				userContent = `请解释下面的内容。要求：使用 ${language} 语言进行回复；请不要包含对本提示词的任何解释，直接给出回复： \n\n` + action.selectedText;
				break;
			case "refine":
				userContent = `请对用XML标签<INPUT>包裹的用户输入内容进行优化或润色，并保持原内容的含义和完整性。要求：你的输出应当与用户输入内容的语言相同。；请不要包含对本提示词的任何解释，直接给出回复；请不要输出XML标签，直接输出优化后的内容: \n\n<INPUT>${action.selectedText ?? ""}</INPUT>`;
				break;
			default:
				if (!action.prompt) {
					userContent = action.selectedText || "";
					break;
				}
				if (action.prompt.includes("{{text}}")) {
					userContent = action.prompt.replaceAll("{{text}}", action.selectedText);
					break;
				}
				userContent = action.prompt + "\n\n" + action.selectedText;
		}
		promptContentRef.current = userContent;
	}, [action, language]);
	const fetchResult = (0, import_react.useCallback)(() => {
		const setAskId = (id) => {
			askId.current = id;
		};
		const onStream = () => {
			setIsContented(true);
			scrollToBottom?.();
		};
		const onFinish = (content) => {
			setContentToCopy(content);
			setIsLoading(false);
		};
		const onError = (error$1) => {
			setIsLoading(false);
			setError(error$1.message);
		};
		if (!assistantRef.current || !topicRef.current) return;
		logger$1.debug("Before peocess message", { assistant: assistantRef.current });
		processMessages(assistantRef.current, topicRef.current, promptContentRef.current, setAskId, onStream, onFinish, onError);
	}, [scrollToBottom]);
	(0, import_react.useEffect)(() => {
		fetchResult();
	}, [fetchResult]);
	const allMessages = useTopicMessages(topicRef.current?.id || "");
	const messageContent = (0, import_react.useMemo)(() => {
		const assistantMessages = allMessages.filter((message) => message.role === "assistant");
		const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
		return lastAssistantMessage ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MessageContent_default, { message: lastAssistantMessage }, lastAssistantMessage.id) : null;
	}, [allMessages]);
	const handlePause = () => {
		if (askId.current) {
			abortCompletion(askId.current);
			setIsLoading(false);
		}
		if (topicRef.current?.id) pauseTrace(topicRef.current.id);
	};
	const handleRegenerate = () => {
		setContentToCopy("");
		setIsLoading(true);
		fetchResult();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container$1, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(MenuContainer$1, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalHeader$1, {
				onClick: () => setShowOriginal(!showOriginal),
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: showOriginal ? t("selection.action.window.original_hide") : t("selection.action.window.original_show") }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, {
					size: 14,
					className: showOriginal ? "expanded" : ""
				})]
			}) }),
			showOriginal && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalContent$1, { children: [action.selectedText, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OriginalContentCopyWrapper$1, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CopyButton_default, {
				textToCopy: action.selectedText,
				tooltip: t("selection.action.window.original_copy"),
				size: 12
			}) })] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Result$1, { children: [!isContented && isLoading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
				style: { fontSize: 16 },
				spin: true
			}), messageContent] }),
			error && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorMsg$1, { children: error })
		] }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FooterPadding$1, {}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WindowFooter_default, {
			loading: isLoading,
			onPause: handlePause,
			onRegenerate: handleRegenerate,
			content: contentToCopy
		})
	] });
});
const Container$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`display:flex;flex-direction:column;align-items:center;justify-content:center;width:100%;`]);
const Result$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "Result" })([`margin-top:4px;width:100%;`]);
const MenuContainer$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "MenuContainer" })([`display:flex;width:100%;flex-direction:row;align-items:center;justify-content:flex-end;`]);
const OriginalHeader$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalHeader" })([`display:flex;align-items:center;justify-content:space-between;cursor:pointer;color:var(--color-text-secondary);font-size:12px;&:hover{color:var(--color-primary);}.lucide{transition:transform 0.2s ease;&.expanded{transform:rotate(180deg);}}`]);
const OriginalContent$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContent" })([`padding:8px;margin-top:8px;margin-bottom:12px;background-color:var(--color-background-soft);border-radius:4px;color:var(--color-text-secondary);font-size:12px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const OriginalContentCopyWrapper$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContentCopyWrapper" })([`display:flex;justify-content:flex-end;`]);
const FooterPadding$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "FooterPadding" })([`min-height:12px;`]);
const ErrorMsg$1 = /* @__PURE__ */ dt.div.withConfig({ displayName: "ErrorMsg" })([`color:var(--color-error);background:rgba(255,0,0,0.15);border:1px solid var(--color-error);padding:8px 12px;border-radius:4px;margin-bottom:12px;font-size:13px;word-break:break-all;`]);
var ActionGeneral_default = ActionGeneral;
await init_es();
const logger = loggerService.withContext("ActionTranslate");
const ActionTranslate = ({ action, scrollToBottom }) => {
	const { t } = useTranslation();
	const { translateModelPrompt, language } = useSettings();
	const [targetLanguage, setTargetLanguage] = (0, import_react.useState)(LanguagesEnum.enUS);
	const [alterLanguage, setAlterLanguage] = (0, import_react.useState)(LanguagesEnum.zhCN);
	const [error, setError] = (0, import_react.useState)("");
	const [showOriginal, setShowOriginal] = (0, import_react.useState)(false);
	const [isContented, setIsContented] = (0, import_react.useState)(false);
	const [isLoading, setIsLoading] = (0, import_react.useState)(true);
	const [contentToCopy, setContentToCopy] = (0, import_react.useState)("");
	const { getLanguageByLangcode } = useTranslate();
	const initialized = (0, import_react.useRef)(false);
	const assistantRef = (0, import_react.useRef)(null);
	const topicRef = (0, import_react.useRef)(null);
	const askId = (0, import_react.useRef)("");
	(0, import_react.useEffect)(() => {
		runAsyncFunction(async () => {
			const biDirectionLangPair = await databases_default.settings.get({ id: "translate:bidirectional:pair" });
			let targetLang;
			let alterLang;
			if (!biDirectionLangPair || !biDirectionLangPair.value[0]) {
				const lang = getLanguageByLangcode(language);
				if (lang !== UNKNOWN) targetLang = lang;
				else {
					logger.warn("Fallback to zh-CN");
					targetLang = LanguagesEnum.zhCN;
				}
			} else targetLang = getLanguageByLangcode(biDirectionLangPair.value[0]);
			if (!biDirectionLangPair || !biDirectionLangPair.value[1]) alterLang = LanguagesEnum.enUS;
			else alterLang = getLanguageByLangcode(biDirectionLangPair.value[1]);
			setTargetLanguage(targetLang);
			setAlterLanguage(alterLang);
		});
	}, [getLanguageByLangcode, language]);
	(0, import_react.useEffect)(() => {
		if (initialized.current || !action.selectedText) return;
		initialized.current = true;
		const currentAssistant = getDefaultTranslateAssistant(targetLanguage, action.selectedText);
		assistantRef.current = currentAssistant;
		topicRef.current = getDefaultTopic(currentAssistant.id);
	}, [
		action,
		targetLanguage,
		translateModelPrompt
	]);
	const fetchResult = (0, import_react.useCallback)(async () => {
		if (!assistantRef.current || !topicRef.current || !action.selectedText) return;
		const setAskId = (id) => {
			askId.current = id;
		};
		const onStream = () => {
			setIsContented(true);
			scrollToBottom?.();
		};
		const onFinish = (content) => {
			setContentToCopy(content);
			setIsLoading(false);
		};
		const onError = (error$1) => {
			setIsLoading(false);
			setError(error$1.message);
		};
		setIsLoading(true);
		let sourceLanguageCode;
		try {
			sourceLanguageCode = await detectLanguage(action.selectedText);
		} catch (err) {
			onError(err instanceof Error ? err : /* @__PURE__ */ new Error("An error occurred"));
			logger.error("Error detecting language:", err);
			return;
		}
		let translateLang;
		if (sourceLanguageCode === UNKNOWN.langCode) {
			logger.debug("Unknown source language. Just use target language.");
			translateLang = targetLanguage;
		} else {
			logger.debug("Detected Language: ", { sourceLanguage: sourceLanguageCode });
			if (sourceLanguageCode === targetLanguage.langCode) translateLang = alterLanguage;
			else translateLang = targetLanguage;
		}
		const assistant = getDefaultTranslateAssistant(translateLang, action.selectedText);
		assistantRef.current = assistant;
		processMessages(assistant, topicRef.current, assistant.content, setAskId, onStream, onFinish, onError);
	}, [
		action,
		targetLanguage,
		alterLanguage,
		scrollToBottom
	]);
	(0, import_react.useEffect)(() => {
		fetchResult();
	}, [fetchResult]);
	const allMessages = useTopicMessages(topicRef.current?.id || "");
	const messageContent = (0, import_react.useMemo)(() => {
		const assistantMessages = allMessages.filter((message) => message.role === "assistant");
		const lastAssistantMessage = assistantMessages[assistantMessages.length - 1];
		return lastAssistantMessage ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MessageContent_default, { message: lastAssistantMessage }, lastAssistantMessage.id) : null;
	}, [allMessages]);
	const handleChangeLanguage = (targetLanguage$1, alterLanguage$1) => {
		setTargetLanguage(targetLanguage$1);
		setAlterLanguage(alterLanguage$1);
		databases_default.settings.put({
			id: "translate:bidirectional:pair",
			value: [targetLanguage$1.langCode, alterLanguage$1.langCode]
		});
	};
	const handlePause = () => {
		if (askId.current) {
			abortCompletion(askId.current);
			setIsLoading(false);
		}
	};
	const handleRegenerate = () => {
		setContentToCopy("");
		setIsLoading(true);
		fetchResult();
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
		/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Container, { children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(MenuContainer, { children: [
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.any.language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Globe, {
						size: 16,
						style: { flexShrink: 0 }
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowRightToLine, {
					size: 16,
					color: "var(--color-text-3)",
					style: { margin: "0 2px" }
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.target_language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LanguageSelect_default, {
						value: targetLanguage.langCode,
						style: {
							minWidth: 80,
							maxWidth: 200,
							flex: "auto"
						},
						listHeight: 160,
						title: t("translate.target_language"),
						optionFilterProp: "label",
						onChange: (value) => handleChangeLanguage(getLanguageByLangcode(value), alterLanguage),
						disabled: isLoading
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowRightFromLine, {
					size: 16,
					color: "var(--color-text-3)",
					style: { margin: "0 2px" }
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("translate.alter_language"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LanguageSelect_default, {
						value: alterLanguage.langCode,
						style: {
							minWidth: 80,
							maxWidth: 200,
							flex: "auto"
						},
						listHeight: 160,
						title: t("translate.alter_language"),
						optionFilterProp: "label",
						onChange: (value) => handleChangeLanguage(targetLanguage, getLanguageByLangcode(value)),
						disabled: isLoading
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
					placement: "bottom",
					title: t("selection.action.translate.smart_translate_tips"),
					arrow: true,
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(QuestionIcon, {
						size: 14,
						style: { marginLeft: 4 }
					})
				}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Spacer, {}),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalHeader, {
					onClick: () => setShowOriginal(!showOriginal),
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", { children: showOriginal ? t("selection.action.window.original_hide") : t("selection.action.window.original_show") }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, {
						size: 14,
						className: showOriginal ? "expanded" : ""
					})]
				})
			] }),
			showOriginal && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(OriginalContent, { children: [
				action.selectedText,
				" ",
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OriginalContentCopyWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CopyButton_default, {
					textToCopy: action.selectedText,
					tooltip: t("selection.action.window.original_copy"),
					size: 12
				}) })
			] }),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Result, { children: [!isContented && isLoading && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LoadingOutlined_default, {
				style: { fontSize: 16 },
				spin: true
			}), messageContent] }),
			error && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ErrorMsg, { children: error })
		] }),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FooterPadding, {}),
		/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WindowFooter_default, {
			loading: isLoading,
			onPause: handlePause,
			onRegenerate: handleRegenerate,
			content: contentToCopy
		})
	] });
};
const Container = /* @__PURE__ */ dt.div.withConfig({ displayName: "Container" })([`display:flex;flex-direction:column;align-items:center;flex:1;width:100%;`]);
const Result = /* @__PURE__ */ dt.div.withConfig({ displayName: "Result" })([`margin-top:16px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const MenuContainer = /* @__PURE__ */ dt.div.withConfig({ displayName: "MenuContainer" })([`display:flex;width:100%;flex-direction:row;align-items:center;justify-content:space-between;`]);
const OriginalHeader = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalHeader" })([`display:flex;align-items:center;justify-content:space-between;cursor:pointer;color:var(--color-text-secondary);font-size:12px;padding:4px 0;white-space:nowrap;&:hover{color:var(--color-primary);}.lucide{transition:transform 0.2s ease;&.expanded{transform:rotate(180deg);}}`]);
const OriginalContent = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContent" })([`margin-top:8px;padding:8px;background-color:var(--color-background-soft);border-radius:4px;color:var(--color-text-secondary);font-size:12px;white-space:pre-wrap;word-break:break-word;width:100%;`]);
const OriginalContentCopyWrapper = /* @__PURE__ */ dt.div.withConfig({ displayName: "OriginalContentCopyWrapper" })([`display:flex;justify-content:flex-end;`]);
const FooterPadding = /* @__PURE__ */ dt.div.withConfig({ displayName: "FooterPadding" })([`min-height:12px;`]);
const ErrorMsg = /* @__PURE__ */ dt.div.withConfig({ displayName: "ErrorMsg" })([`color:var(--color-error);background:rgba(255,0,0,0.15);border:1px solid var(--color-error);padding:8px 12px;border-radius:4px;margin-bottom:12px;font-size:13px;word-break:break-all;`]);
const Spacer = /* @__PURE__ */ dt.div.withConfig({ displayName: "Spacer" })([`flex-grow:0.5;`]);
const QuestionIcon = /* @__PURE__ */ dt(CircleQuestionMark).withConfig({ displayName: "QuestionIcon" })([`cursor:pointer;color:var(--color-text-3);`]);
var ActionTranslate_default = ActionTranslate;
const SelectionActionApp = () => {
	const { language, customCss } = useSettings();
	const { t } = useTranslation();
	const [action, setAction] = (0, import_react.useState)(null);
	const isActionLoaded = (0, import_react.useRef)(false);
	const { isAutoClose, isAutoPin, actionWindowOpacity } = useSelectionAssistant();
	const [isPinned, setIsPinned] = (0, import_react.useState)(isAutoPin);
	const [isWindowFocus, setIsWindowFocus] = (0, import_react.useState)(true);
	const [showOpacitySlider, setShowOpacitySlider] = (0, import_react.useState)(false);
	const [opacity, setOpacity] = (0, import_react.useState)(actionWindowOpacity);
	const shouldCloseWhenBlur = (0, import_react.useRef)(false);
	const contentElementRef = (0, import_react.useRef)(null);
	const isAutoScrollEnabled = (0, import_react.useRef)(true);
	const lastScrollHeight = (0, import_react.useRef)(0);
	(0, import_react.useEffect)(() => {
		const actionListenRemover = window.electron?.ipcRenderer.on(IpcChannel.Selection_UpdateActionData, (_, actionItem) => {
			setAction(actionItem);
			isActionLoaded.current = true;
		});
		window.addEventListener("focus", handleWindowFocus);
		window.addEventListener("blur", handleWindowBlur);
		return () => {
			actionListenRemover();
			window.removeEventListener("focus", handleWindowFocus);
			window.removeEventListener("blur", handleWindowBlur);
		};
	}, []);
	(0, import_react.useEffect)(() => {
		if (isAutoPin) {
			window.api.selection.pinActionWindow(true);
			setIsPinned(true);
		} else if (!isActionLoaded.current) {
			window.api.selection.pinActionWindow(false);
			setIsPinned(false);
		}
	}, [isAutoPin]);
	(0, import_react.useEffect)(() => {
		shouldCloseWhenBlur.current = isAutoClose && !isPinned;
	}, [isAutoClose, isPinned]);
	(0, import_react.useEffect)(() => {
		i18n_default.changeLanguage(language || navigator.language || defaultLanguage);
	}, [language]);
	(0, import_react.useEffect)(() => {
		let customCssElement = document.getElementById("user-defined-custom-css");
		if (customCssElement) customCssElement.remove();
		if (customCss) {
			customCssElement = document.createElement("style");
			customCssElement.id = "user-defined-custom-css";
			customCssElement.textContent = customCss;
			document.head.appendChild(customCssElement);
		}
	}, [customCss]);
	(0, import_react.useEffect)(() => {
		const contentEl = contentElementRef.current;
		if (contentEl) {
			contentEl.addEventListener("scroll", handleUserScroll);
			lastScrollHeight.current = contentEl.scrollHeight;
		}
		return () => {
			if (contentEl) contentEl.removeEventListener("scroll", handleUserScroll);
		};
	}, [action]);
	(0, import_react.useEffect)(() => {
		if (action) document.title = `${action.isBuiltIn ? t(action.name) : action.name} - ${t("selection.name")}`;
	}, [action, t]);
	(0, import_react.useEffect)(() => {
		if (!isActionLoaded.current) setOpacity(actionWindowOpacity);
	}, [actionWindowOpacity]);
	const handleMinimize = () => {
		window.api.selection.minimizeActionWindow();
	};
	const handleClose = () => {
		window.api.selection.closeActionWindow();
	};
	const togglePin = () => {
		setIsPinned(!isPinned);
		window.api.selection.pinActionWindow(!isPinned);
	};
	const handleWindowFocus = () => {
		setIsWindowFocus(true);
	};
	const handleWindowBlur = () => {
		if (shouldCloseWhenBlur.current) {
			handleClose();
			return;
		}
		setIsWindowFocus(false);
	};
	const handleOpacityChange = (value) => {
		setOpacity(value);
	};
	const handleScrollToBottom = (0, import_react.useCallback)(() => {
		if (contentElementRef.current && isAutoScrollEnabled.current) contentElementRef.current.scrollTo({
			top: contentElementRef.current.scrollHeight,
			behavior: "smooth"
		});
	}, []);
	const handleUserScroll = () => {
		if (!contentElementRef.current) return;
		const { scrollTop, scrollHeight, clientHeight } = contentElementRef.current;
		const contentIncreased = scrollHeight > lastScrollHeight.current;
		lastScrollHeight.current = scrollHeight;
		if (contentIncreased && isAutoScrollEnabled.current) return;
		const isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 32;
		if (isAtBottom) isAutoScrollEnabled.current = true;
		else isAutoScrollEnabled.current = false;
	};
	if (!action) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(WindowFrame, {
		$opacity: opacity / 100,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TitleBar, {
			$isWindowFocus: isWindowFocus,
			style: isMac ? { paddingLeft: "70px" } : {},
			children: [
				action.icon && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TitleBarIcon, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DynamicIcon, {
					name: action.icon,
					size: 16,
					style: { color: "var(--color-text-1)" },
					fallback: () => {}
				}) }),
				/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TitleBarCaption, { children: action.isBuiltIn ? t(action.name) : action.name }),
				/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(TitleBarButtons, { children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
						title: isPinned ? t("selection.action.window.pinned") : t("selection.action.window.pin"),
						placement: "bottom",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
							type: "text",
							icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Pin, {
								size: 14,
								className: isPinned ? "pinned" : ""
							}),
							onClick: togglePin,
							className: isPinned ? "pinned" : ""
						})
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(tooltip_default, {
						title: t("selection.action.window.opacity"),
						placement: "bottom",
						...showOpacitySlider ? { open: false } : {},
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
							type: "text",
							icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Droplet, { size: 14 }),
							onClick: () => setShowOpacitySlider(!showOpacitySlider),
							className: showOpacitySlider ? "active" : "",
							style: { paddingBottom: "2px" }
						})
					}),
					showOpacitySlider && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(OpacitySlider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(slider_default, {
						vertical: true,
						min: 20,
						max: 100,
						value: opacity,
						onChange: handleOpacityChange,
						onChangeComplete: () => setShowOpacitySlider(false),
						tooltip: { formatter: (value) => `${value}%` }
					}) }),
					!isMac && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
						type: "text",
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Minus, { size: 16 }),
						onClick: handleMinimize
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WinButton, {
						type: "text",
						icon: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, { size: 16 }),
						onClick: handleClose,
						className: "close"
					})] })
				] })
			]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MainContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content, {
			ref: contentElementRef,
			children: [action.id == "translate" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionTranslate_default, {
				action,
				scrollToBottom: handleScrollToBottom
			}), action.id != "translate" && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ActionGeneral_default, {
				action,
				scrollToBottom: handleScrollToBottom
			})]
		}) })]
	});
};
const WindowFrame = /* @__PURE__ */ dt.div.withConfig({ displayName: "WindowFrame" })([`position:relative;display:flex;flex-direction:column;width:calc(100% - 6px);height:calc(100% - 6px);margin:2px;background-color:var(--color-background);border:1px solid var(--color-border);box-shadow:0px 0px 2px var(--color-text-3);border-radius:8px;overflow:hidden;box-sizing:border-box;opacity:`, `;`], (props) => props.$opacity);
const TitleBar = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBar" })([`display:flex;align-items:center;flex-direction:row;height:32px;padding:0 8px;background-color:`, `;transition:background-color 0.3s ease;-webkit-app-region:drag;`], (props) => props.$isWindowFocus ? "var(--color-background-mute)" : "var(--color-background-soft)");
const TitleBarIcon = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarIcon" })([`display:flex;align-items:center;justify-content:center;margin-left:4px;`]);
const TitleBarCaption = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarCaption" })([`margin-left:8px;font-size:14px;font-weight:400;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--color-text-1);`]);
const TitleBarButtons = /* @__PURE__ */ dt.div.withConfig({ displayName: "TitleBarButtons" })([`display:flex;gap:8px;-webkit-app-region:no-drag;position:relative;.lucide{&.pinned{color:var(--color-primary);}}`]);
const WinButton = /* @__PURE__ */ dt(button_default).withConfig({ displayName: "WinButton" })([`display:flex;align-items:center;justify-content:center;width:24px;height:24px;padding:0;border:none;background:transparent;border-radius:4px;transition:all 0.2s;color:var(--color-icon);.anticon{display:flex;align-items:center;justify-content:center;}svg{stroke-width:2;transition:transform 0.2s ease;}&.pinned{svg{transform:rotate(45deg);}&:hover{background-color:var(--color-primary-mute) !important;}}&.close{&:hover{background-color:var(--color-error) !important;color:var(--color-white) !important;}}&.active{background-color:var(--color-primary-mute) !important;color:var(--color-primary) !important;}&:hover{background-color:var(--color-hover) !important;color:var(--color-icon-white) !important;}`]);
const MainContainer = /* @__PURE__ */ dt.div.withConfig({ displayName: "MainContainer" })([`display:flex;justify-content:center;width:100%;height:100%;overflow:auto;`]);
const Content = /* @__PURE__ */ dt.div.withConfig({ displayName: "Content" })([`display:flex;flex-direction:column;flex:1;padding:16px;overflow:auto;font-size:14px;-webkit-app-region:none;user-select:text;max-width:1280px;`]);
const OpacitySlider = /* @__PURE__ */ dt.div.withConfig({ displayName: "OpacitySlider" })([`position:absolute;left:42px;top:100%;margin-top:8px;background-color:var(--color-background-mute);padding:16px 8px 12px 8px;border-radius:4px;box-shadow:0 2px 4px rgba(0,0,0,0.25);height:120px;align-items:center;justify-content:center;z-index:10000;opacity:1 !important;.ant-slider{height:100%;margin:0;}.ant-slider-rail{background-color:var(--color-border);}.ant-slider-track{background-color:var(--color-primary);}.ant-slider-handle{border-color:var(--color-primary);&:hover{border-color:var(--color-primary);}&.ant-slider-handle-active{border-color:var(--color-primary);box-shadow:0 0 0 2px var(--color-primary-mute);}}`]);
var SelectionActionApp_default = SelectionActionApp;
loggerService.initWindowSource("SelectionActionWindow");
function initKeyv() {
	window.keyv = new import_lib.default();
	window.keyv.init();
}
initKeyv();
StoreSyncService_default.subscribe();
const App = () => {
	(0, import_react.useEffect)(() => {
		window.toast = getToastUtilities();
	}, []);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Provider_default, {
		store: store_default,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ThemeProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AntdProvider_default, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CodeStyleProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PersistGate, {
			loading: null,
			persistor,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectionActionApp_default, {})
		}) }) }) })
	});
};
const root = (0, import_client.createRoot)(document.getElementById("root"));
root.render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, {}));
