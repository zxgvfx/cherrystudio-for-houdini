const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./angular-html-CLhSf0iA.js","./angular-html-C1co-YSB.js","./html-B69D7etl.js","./css-Bn7HiqCl.js","./javascript-BONLpVbI.js","./angular-ts-Bq9-iqwz.js","./scss-B4vYyN1a.js","./apl-B-ZZEnmz.js","./java-DwAhBIJR.js","./json-CqzspFhM.js","./xml-CZr_DZXD.js","./astro-Di2apbCf.js","./postcss-TRnT9i1b.js","./tsx-BT_rT7rO.js","./typescript-BV9GV7aZ.js","./blade-DovXqB2V.js","./html-derivative-YKrG4DZR.js","./sql-3BnwgXQM.js","./bsl-C0pLI7Rq.js","./sdbl-Cwa9pGbP.js","./c-BuMNKEro.js","./c-B0ZcFDT2.js","./cairo-CAVdeAiP.js","./python-Cha8KAh1.js","./cmake-B8ZEWvNI.js","./cmake-BtOeXM56.js","./cobol-DX5dGMw2.js","./coffee-5IymWcdm.js","./cpp-DhaONcvC.js","./cpp-BItNADCd.js","./glsl-DFaCwZiq.js","./regexp-b4Isn4uD.js","./crystal-C474fC1m.js","./shellscript-CcsN1D_V.js","./csharp-DvKTTmTk.js","./csharp-BoOVXitk.js","./css-CFC69hL5.js","./diff-BAxRm3wl.js","./diff-DWPQoceE.js","./edge-CPxf-0MP.js","./elixir-DFkwd1Io.js","./elm-DqRbx9pC.js","./erb-3IJs0s8u.js","./graphql-BZgUgYkX.js","./jsx-CKs8HnqG.js","./haml-CYkFAMdm.js","./lua-DQkvOtCf.js","./ruby-Ld3gzOk0.js","./yaml-B8dKlX83.js","./erlang-Dn_jAQm8.js","./markdown-Dv4yEvBE.js","./fortran-fixed-form-BVvS3CeF.js","./fortran-free-form-CS9cvh6C.js","./fortran-free-form-CMevZ5_9.js","./fsharp-C-CQ5Hwr.js","./gdresource-CHo73oR2.js","./gdscript-CpEdB0tR.js","./gdshader-BKWXytVZ.js","./gdscript-DcZPuBFV.js","./gdshader-CB2Da4Ja.js","./git-commit-Aps1KJVY.js","./git-rebase-7RyK2c0F.js","./glimmer-js-Dd35aBOl.js","./glimmer-ts-BqvoZLFs.js","./glsl-5yEfoLw5.js","./go-iPheS-kq.js","./go-CPoNSRoJ.js","./graphql-8Es4QIZn.js","./hack-DaWGwXxK.js","./haml-ViksRxt9.js","./handlebars-5hTptIcj.js","./haxe-DukXPCjY.js","./haxe-BNgEbDH6.js","./hlsl-DtuS6XoE.js","./hlsl-BJMg8NCg.js","./html-BxipkcDv.js","./html-derivative-DKRVEMqD.js","./http-JO10yfEl.js","./hxml-Cjadp9eB.js","./java-9mbFxJUB.js","./javascript-D5dNfVme.js","./jinja-4sJKbs1C.js","./jison-DSzNfQTQ.js","./json-LRmMnCN7.js","./jsx-CTYK6TV5.js","./julia-BN7uG_Fi.js","./r-B0xa9n5P.js","./latex-Dp_gVk_D.js","./tex-Ck-nKO-Z.js","./less-Eip8g5EN.js","./less-DEVGURCs.js","./liquid-D1eULOmS.js","./lua-Pg-n4n4e.js","./markdown-BfJUJqnE.js","./marko-D0-nTItI.js","./mdc-CfH0_wvs.js","./nginx-Tadh9eQs.js","./nim-BIoXls5U.js","./perl-DFR5-V1b.js","./php-BHsUzYFb.js","./php-C-9PzMRT.js","./postcss-BHjr3rob.js","./pug-B8nWteL_.js","./python-BqTxEWde.js","./qml-DyB232Ot.js","./r-CuOiyelf.js","./razor-DmyyxmC7.js","./regexp-CqiqKJVB.js","./rst-BCtvVUMe.js","./ruby-ChM1EpzV.js","./sas-DDtYYxyD.js","./scss-FVUDPqDe.js","./sdbl-D6OWllNc.js","./shaderlab-jWnaqKN_.js","./shellscript-BUtKaIzA.js","./shellsession-DD9B_uJ9.js","./soy-BIHeIn1W.js","./sparql-4oLOD8Ww.js","./turtle-CytR0uzQ.js","./sql-8c5I0h2b.js","./stata-DTDkE664.js","./stylus-DJYkuzJ1.js","./stylus-B32nMu6_.js","./svelte-D31aakhX.js","./templ-DEmykQRU.js","./tex-9hE2MvTu.js","./ts-tags-DGNBrDF6.js","./tsx-B3_GyDhV.js","./turtle-CK1facO0.js","./twig-CNwzHCmG.js","./typescript-UDgxddJj.js","./vue-BnBnusap.js","./vue-CodeBCAS.js","./vue-html-C_QqBuYj.js","./vue-vine-D1nUkunW.js","./xml-B9zrtOkV.js","./xsl-CTM_gp5m.js","./yaml-Du6PPDFW.js"])))=>i.map(i=>d[i]);
import { A as splitLines, B as splitToken, C as splitTokens, D as stringifyTokenStyle, E as toArray, F as tokenizeAnsiWithTheme, G as tokenizeWithTheme, H as tokensToHast, I as transformerDecorations, J as warnDeprecated, K as ShikiError, b as addClassToHast, c as applyColorReplacements, d as createCssVariablesTheme, e as createHighlighterCore, f as createHighlighterCoreSync, g as createPositionConverter, h as createShikiInternal, i as createShikiInternalSync, j as createSingletonShorthands, k as createdBundledHighlighter, l as enableDeprecationWarnings, m as flatTokenVariants, n as getSingletonHighlighterCore, o as getTokenStyleObject, p as guessEmbeddedLanguages, q as hastToHtml, r as isNoneTheme, s as isPlainLang, t as isSpecialLang, u as isSpecialTheme, v as makeSingletonHighlighter, w as makeSingletonHighlighterCore, x as normalizeGetter, y as normalizeTheme, z as resolveColorReplacements } from "./dist-X8kR-wKB.js";
import { b as __vitePreload } from "./preload-helper-T0xubxxH.js";
const bundledLanguagesInfo = [
	{
		"id": "abap",
		"name": "ABAP",
		"import": (() => __vitePreload(() => import("./abap-AwI3u_tj.js"), [], import.meta.url))
	},
	{
		"id": "actionscript-3",
		"name": "ActionScript",
		"import": (() => __vitePreload(() => import("./actionscript-3-B8DRAnxG.js"), [], import.meta.url))
	},
	{
		"id": "ada",
		"name": "Ada",
		"import": (() => __vitePreload(() => import("./ada-BxgwZdHz.js"), [], import.meta.url))
	},
	{
		"id": "angular-html",
		"name": "Angular HTML",
		"import": (() => __vitePreload(() => import("./angular-html-CLhSf0iA.js"), __vite__mapDeps([0,1,2,3,4]), import.meta.url))
	},
	{
		"id": "angular-ts",
		"name": "Angular TypeScript",
		"import": (() => __vitePreload(() => import("./angular-ts-Bq9-iqwz.js"), __vite__mapDeps([5,1,2,3,4,6]), import.meta.url))
	},
	{
		"id": "apache",
		"name": "Apache Conf",
		"import": (() => __vitePreload(() => import("./apache-BW3NNLIG.js"), [], import.meta.url))
	},
	{
		"id": "apex",
		"name": "Apex",
		"import": (() => __vitePreload(() => import("./apex-BmmK3SEA.js"), [], import.meta.url))
	},
	{
		"id": "apl",
		"name": "APL",
		"import": (() => __vitePreload(() => import("./apl-B-ZZEnmz.js"), __vite__mapDeps([7,3,2,4,8,9,10]), import.meta.url))
	},
	{
		"id": "applescript",
		"name": "AppleScript",
		"import": (() => __vitePreload(() => import("./applescript-Y8eSS2UB.js"), [], import.meta.url))
	},
	{
		"id": "ara",
		"name": "Ara",
		"import": (() => __vitePreload(() => import("./ara-zO4TG8yf.js"), [], import.meta.url))
	},
	{
		"id": "asciidoc",
		"name": "AsciiDoc",
		"aliases": ["adoc"],
		"import": (() => __vitePreload(() => import("./asciidoc-OUefE6os.js"), [], import.meta.url))
	},
	{
		"id": "asm",
		"name": "Assembly",
		"import": (() => __vitePreload(() => import("./asm-BeZtUjQA.js"), [], import.meta.url))
	},
	{
		"id": "astro",
		"name": "Astro",
		"import": (() => __vitePreload(() => import("./astro-Di2apbCf.js"), __vite__mapDeps([11,3,4,9,12,13,14]), import.meta.url))
	},
	{
		"id": "awk",
		"name": "AWK",
		"import": (() => __vitePreload(() => import("./awk-CmiKIgol.js"), [], import.meta.url))
	},
	{
		"id": "ballerina",
		"name": "Ballerina",
		"import": (() => __vitePreload(() => import("./ballerina-Bzv-LdOp.js"), [], import.meta.url))
	},
	{
		"id": "bat",
		"name": "Batch File",
		"aliases": ["batch"],
		"import": (() => __vitePreload(() => import("./bat-D3FJOzZ1.js"), [], import.meta.url))
	},
	{
		"id": "beancount",
		"name": "Beancount",
		"import": (() => __vitePreload(() => import("./beancount-Cnt4gDZV.js"), [], import.meta.url))
	},
	{
		"id": "berry",
		"name": "Berry",
		"aliases": ["be"],
		"import": (() => __vitePreload(() => import("./berry-Ds9rYM6J.js"), [], import.meta.url))
	},
	{
		"id": "bibtex",
		"name": "BibTeX",
		"import": (() => __vitePreload(() => import("./bibtex-SZldLsT0.js"), [], import.meta.url))
	},
	{
		"id": "bicep",
		"name": "Bicep",
		"import": (() => __vitePreload(() => import("./bicep-OQ4iNJx5.js"), [], import.meta.url))
	},
	{
		"id": "blade",
		"name": "Blade",
		"import": (() => __vitePreload(() => import("./blade-DovXqB2V.js"), __vite__mapDeps([15,3,16,2,4,8,9,17,10]), import.meta.url))
	},
	{
		"id": "bsl",
		"name": "1C (Enterprise)",
		"aliases": ["1c"],
		"import": (() => __vitePreload(() => import("./bsl-C0pLI7Rq.js"), __vite__mapDeps([18,19]), import.meta.url))
	},
	{
		"id": "c",
		"name": "C",
		"import": (() => __vitePreload(() => import("./c-BuMNKEro.js"), __vite__mapDeps([20,21]), import.meta.url))
	},
	{
		"id": "cadence",
		"name": "Cadence",
		"aliases": ["cdc"],
		"import": (() => __vitePreload(() => import("./cadence-Dj5_uSRY.js"), [], import.meta.url))
	},
	{
		"id": "cairo",
		"name": "Cairo",
		"import": (() => __vitePreload(() => import("./cairo-CAVdeAiP.js"), __vite__mapDeps([22,23]), import.meta.url))
	},
	{
		"id": "clarity",
		"name": "Clarity",
		"import": (() => __vitePreload(() => import("./clarity-C__3tqY7.js"), [], import.meta.url))
	},
	{
		"id": "clojure",
		"name": "Clojure",
		"aliases": ["clj"],
		"import": (() => __vitePreload(() => import("./clojure-CJBVKbHd.js"), [], import.meta.url))
	},
	{
		"id": "cmake",
		"name": "CMake",
		"import": (() => __vitePreload(() => import("./cmake-B8ZEWvNI.js"), __vite__mapDeps([24,25]), import.meta.url))
	},
	{
		"id": "cobol",
		"name": "COBOL",
		"import": (() => __vitePreload(() => import("./cobol-DX5dGMw2.js"), __vite__mapDeps([26,3,2,4,8]), import.meta.url))
	},
	{
		"id": "codeowners",
		"name": "CODEOWNERS",
		"import": (() => __vitePreload(() => import("./codeowners-DIlRlQKa.js"), [], import.meta.url))
	},
	{
		"id": "codeql",
		"name": "CodeQL",
		"aliases": ["ql"],
		"import": (() => __vitePreload(() => import("./codeql-CRWw7J9Q.js"), [], import.meta.url))
	},
	{
		"id": "coffee",
		"name": "CoffeeScript",
		"aliases": ["coffeescript"],
		"import": (() => __vitePreload(() => import("./coffee-5IymWcdm.js"), __vite__mapDeps([27,4]), import.meta.url))
	},
	{
		"id": "common-lisp",
		"name": "Common Lisp",
		"aliases": ["lisp"],
		"import": (() => __vitePreload(() => import("./common-lisp-B-xQB-x7.js"), [], import.meta.url))
	},
	{
		"id": "coq",
		"name": "Coq",
		"import": (() => __vitePreload(() => import("./coq-DZ3E104X.js"), [], import.meta.url))
	},
	{
		"id": "cpp",
		"name": "C++",
		"aliases": ["c++"],
		"import": (() => __vitePreload(() => import("./cpp-DhaONcvC.js"), __vite__mapDeps([28,21,29,30,31,17]), import.meta.url))
	},
	{
		"id": "crystal",
		"name": "Crystal",
		"import": (() => __vitePreload(() => import("./crystal-C474fC1m.js"), __vite__mapDeps([32,21,3,2,4,33,17]), import.meta.url))
	},
	{
		"id": "csharp",
		"name": "C#",
		"aliases": ["c#", "cs"],
		"import": (() => __vitePreload(() => import("./csharp-DvKTTmTk.js"), __vite__mapDeps([34,35]), import.meta.url))
	},
	{
		"id": "css",
		"name": "CSS",
		"import": (() => __vitePreload(() => import("./css-CFC69hL5.js"), __vite__mapDeps([36,3]), import.meta.url))
	},
	{
		"id": "csv",
		"name": "CSV",
		"import": (() => __vitePreload(() => import("./csv-BM7ryU1X.js"), [], import.meta.url))
	},
	{
		"id": "cue",
		"name": "CUE",
		"import": (() => __vitePreload(() => import("./cue-BZQGS32_.js"), [], import.meta.url))
	},
	{
		"id": "cypher",
		"name": "Cypher",
		"aliases": ["cql"],
		"import": (() => __vitePreload(() => import("./cypher-DWhij1yi.js"), [], import.meta.url))
	},
	{
		"id": "d",
		"name": "D",
		"import": (() => __vitePreload(() => import("./d-CiDXje0C.js"), [], import.meta.url))
	},
	{
		"id": "dart",
		"name": "Dart",
		"import": (() => __vitePreload(() => import("./dart-N0UFmBuT.js"), [], import.meta.url))
	},
	{
		"id": "dax",
		"name": "DAX",
		"import": (() => __vitePreload(() => import("./dax-Ci97CAi5.js"), [], import.meta.url))
	},
	{
		"id": "desktop",
		"name": "Desktop",
		"import": (() => __vitePreload(() => import("./desktop-BVuOWYLb.js"), [], import.meta.url))
	},
	{
		"id": "diff",
		"name": "Diff",
		"import": (() => __vitePreload(() => import("./diff-BAxRm3wl.js"), __vite__mapDeps([37,38]), import.meta.url))
	},
	{
		"id": "docker",
		"name": "Dockerfile",
		"aliases": ["dockerfile"],
		"import": (() => __vitePreload(() => import("./docker-DeFYHpc-.js"), [], import.meta.url))
	},
	{
		"id": "dotenv",
		"name": "dotEnv",
		"import": (() => __vitePreload(() => import("./dotenv-BcSkhS0B.js"), [], import.meta.url))
	},
	{
		"id": "dream-maker",
		"name": "Dream Maker",
		"import": (() => __vitePreload(() => import("./dream-maker-CUiRCHwJ.js"), [], import.meta.url))
	},
	{
		"id": "edge",
		"name": "Edge",
		"import": (() => __vitePreload(() => import("./edge-CPxf-0MP.js"), __vite__mapDeps([39,3,16,2,4,14]), import.meta.url))
	},
	{
		"id": "elixir",
		"name": "Elixir",
		"import": (() => __vitePreload(() => import("./elixir-DFkwd1Io.js"), __vite__mapDeps([40,3,2,4]), import.meta.url))
	},
	{
		"id": "elm",
		"name": "Elm",
		"import": (() => __vitePreload(() => import("./elm-DqRbx9pC.js"), __vite__mapDeps([41,21,30]), import.meta.url))
	},
	{
		"id": "emacs-lisp",
		"name": "Emacs Lisp",
		"aliases": ["elisp"],
		"import": (() => __vitePreload(() => import("./emacs-lisp-L4F6qFMk.js"), [], import.meta.url))
	},
	{
		"id": "erb",
		"name": "ERB",
		"import": (() => __vitePreload(() => import("./erb-3IJs0s8u.js"), __vite__mapDeps([42,21,29,30,31,17,3,43,4,44,13,14,45,2,8,46,47,33,10,48]), import.meta.url))
	},
	{
		"id": "erlang",
		"name": "Erlang",
		"aliases": ["erl"],
		"import": (() => __vitePreload(() => import("./erlang-Dn_jAQm8.js"), __vite__mapDeps([49,50]), import.meta.url))
	},
	{
		"id": "fennel",
		"name": "Fennel",
		"import": (() => __vitePreload(() => import("./fennel-VsY0v5Ah.js"), [], import.meta.url))
	},
	{
		"id": "fish",
		"name": "Fish",
		"import": (() => __vitePreload(() => import("./fish-DFa86UTC.js"), [], import.meta.url))
	},
	{
		"id": "fluent",
		"name": "Fluent",
		"aliases": ["ftl"],
		"import": (() => __vitePreload(() => import("./fluent-CX4S4Eia.js"), [], import.meta.url))
	},
	{
		"id": "fortran-fixed-form",
		"name": "Fortran (Fixed Form)",
		"aliases": [
			"f",
			"for",
			"f77"
		],
		"import": (() => __vitePreload(() => import("./fortran-fixed-form-BVvS3CeF.js"), __vite__mapDeps([51,52]), import.meta.url))
	},
	{
		"id": "fortran-free-form",
		"name": "Fortran (Free Form)",
		"aliases": [
			"f90",
			"f95",
			"f03",
			"f08",
			"f18"
		],
		"import": (() => __vitePreload(() => import("./fortran-free-form-CMevZ5_9.js"), __vite__mapDeps([53,52]), import.meta.url))
	},
	{
		"id": "fsharp",
		"name": "F#",
		"aliases": ["f#", "fs"],
		"import": (() => __vitePreload(() => import("./fsharp-C-CQ5Hwr.js"), __vite__mapDeps([54,50]), import.meta.url))
	},
	{
		"id": "gdresource",
		"name": "GDResource",
		"import": (() => __vitePreload(() => import("./gdresource-CHo73oR2.js"), __vite__mapDeps([55,56,57]), import.meta.url))
	},
	{
		"id": "gdscript",
		"name": "GDScript",
		"import": (() => __vitePreload(() => import("./gdscript-DcZPuBFV.js"), __vite__mapDeps([58,56]), import.meta.url))
	},
	{
		"id": "gdshader",
		"name": "GDShader",
		"import": (() => __vitePreload(() => import("./gdshader-CB2Da4Ja.js"), __vite__mapDeps([59,57]), import.meta.url))
	},
	{
		"id": "genie",
		"name": "Genie",
		"import": (() => __vitePreload(() => import("./genie-_UXGapC7.js"), [], import.meta.url))
	},
	{
		"id": "gherkin",
		"name": "Gherkin",
		"import": (() => __vitePreload(() => import("./gherkin-Cxi7zS3R.js"), [], import.meta.url))
	},
	{
		"id": "git-commit",
		"name": "Git Commit Message",
		"import": (() => __vitePreload(() => import("./git-commit-Aps1KJVY.js"), __vite__mapDeps([60,38]), import.meta.url))
	},
	{
		"id": "git-rebase",
		"name": "Git Rebase Message",
		"import": (() => __vitePreload(() => import("./git-rebase-7RyK2c0F.js"), __vite__mapDeps([61,33]), import.meta.url))
	},
	{
		"id": "gleam",
		"name": "Gleam",
		"import": (() => __vitePreload(() => import("./gleam-aBZ3WXAa.js"), [], import.meta.url))
	},
	{
		"id": "glimmer-js",
		"name": "Glimmer JS",
		"aliases": ["gjs"],
		"import": (() => __vitePreload(() => import("./glimmer-js-Dd35aBOl.js"), __vite__mapDeps([62,3,2,4,14]), import.meta.url))
	},
	{
		"id": "glimmer-ts",
		"name": "Glimmer TS",
		"aliases": ["gts"],
		"import": (() => __vitePreload(() => import("./glimmer-ts-BqvoZLFs.js"), __vite__mapDeps([63,3,2,4,14]), import.meta.url))
	},
	{
		"id": "glsl",
		"name": "GLSL",
		"import": (() => __vitePreload(() => import("./glsl-5yEfoLw5.js"), __vite__mapDeps([64,21,30]), import.meta.url))
	},
	{
		"id": "gnuplot",
		"name": "Gnuplot",
		"import": (() => __vitePreload(() => import("./gnuplot-YlnpO272.js"), [], import.meta.url))
	},
	{
		"id": "go",
		"name": "Go",
		"import": (() => __vitePreload(() => import("./go-iPheS-kq.js"), __vite__mapDeps([65,66]), import.meta.url))
	},
	{
		"id": "graphql",
		"name": "GraphQL",
		"aliases": ["gql"],
		"import": (() => __vitePreload(() => import("./graphql-8Es4QIZn.js"), __vite__mapDeps([67,43,4,44,13,14]), import.meta.url))
	},
	{
		"id": "groovy",
		"name": "Groovy",
		"import": (() => __vitePreload(() => import("./groovy-CueIYOOZ.js"), [], import.meta.url))
	},
	{
		"id": "hack",
		"name": "Hack",
		"import": (() => __vitePreload(() => import("./hack-DaWGwXxK.js"), __vite__mapDeps([68,3,2,4,17]), import.meta.url))
	},
	{
		"id": "haml",
		"name": "Ruby Haml",
		"import": (() => __vitePreload(() => import("./haml-ViksRxt9.js"), __vite__mapDeps([69,3,45,4]), import.meta.url))
	},
	{
		"id": "handlebars",
		"name": "Handlebars",
		"aliases": ["hbs"],
		"import": (() => __vitePreload(() => import("./handlebars-5hTptIcj.js"), __vite__mapDeps([70,3,2,4,48]), import.meta.url))
	},
	{
		"id": "haskell",
		"name": "Haskell",
		"aliases": ["hs"],
		"import": (() => __vitePreload(() => import("./haskell-DXIpbZ-I.js"), [], import.meta.url))
	},
	{
		"id": "haxe",
		"name": "Haxe",
		"import": (() => __vitePreload(() => import("./haxe-DukXPCjY.js"), __vite__mapDeps([71,72]), import.meta.url))
	},
	{
		"id": "hcl",
		"name": "HashiCorp HCL",
		"import": (() => __vitePreload(() => import("./hcl-Bvx4L4ud.js"), [], import.meta.url))
	},
	{
		"id": "hjson",
		"name": "Hjson",
		"import": (() => __vitePreload(() => import("./hjson-C_CHyj56.js"), [], import.meta.url))
	},
	{
		"id": "hlsl",
		"name": "HLSL",
		"import": (() => __vitePreload(() => import("./hlsl-DtuS6XoE.js"), __vite__mapDeps([73,74]), import.meta.url))
	},
	{
		"id": "html",
		"name": "HTML",
		"import": (() => __vitePreload(() => import("./html-BxipkcDv.js"), __vite__mapDeps([75,3,2,4]), import.meta.url))
	},
	{
		"id": "html-derivative",
		"name": "HTML (Derivative)",
		"import": (() => __vitePreload(() => import("./html-derivative-DKRVEMqD.js"), __vite__mapDeps([76,3,16,2,4]), import.meta.url))
	},
	{
		"id": "http",
		"name": "HTTP",
		"import": (() => __vitePreload(() => import("./http-JO10yfEl.js"), __vite__mapDeps([77,43,4,44,13,14,8,9,33,10]), import.meta.url))
	},
	{
		"id": "hxml",
		"name": "HXML",
		"import": (() => __vitePreload(() => import("./hxml-Cjadp9eB.js"), __vite__mapDeps([78,72]), import.meta.url))
	},
	{
		"id": "hy",
		"name": "Hy",
		"import": (() => __vitePreload(() => import("./hy-DjuvDpsU.js"), [], import.meta.url))
	},
	{
		"id": "imba",
		"name": "Imba",
		"import": (() => __vitePreload(() => import("./imba-dfRw-EYd.js"), [], import.meta.url))
	},
	{
		"id": "ini",
		"name": "INI",
		"aliases": ["properties"],
		"import": (() => __vitePreload(() => import("./ini-bzhvX8mJ.js"), [], import.meta.url))
	},
	{
		"id": "java",
		"name": "Java",
		"import": (() => __vitePreload(() => import("./java-9mbFxJUB.js"), __vite__mapDeps([79,8]), import.meta.url))
	},
	{
		"id": "javascript",
		"name": "JavaScript",
		"aliases": ["js"],
		"import": (() => __vitePreload(() => import("./javascript-D5dNfVme.js"), __vite__mapDeps([80,4]), import.meta.url))
	},
	{
		"id": "jinja",
		"name": "Jinja",
		"import": (() => __vitePreload(() => import("./jinja-4sJKbs1C.js"), __vite__mapDeps([81,3,2,4]), import.meta.url))
	},
	{
		"id": "jison",
		"name": "Jison",
		"import": (() => __vitePreload(() => import("./jison-DSzNfQTQ.js"), __vite__mapDeps([82,4]), import.meta.url))
	},
	{
		"id": "json",
		"name": "JSON",
		"import": (() => __vitePreload(() => import("./json-LRmMnCN7.js"), __vite__mapDeps([83,9]), import.meta.url))
	},
	{
		"id": "json5",
		"name": "JSON5",
		"import": (() => __vitePreload(() => import("./json5-DTKkUGuR.js"), [], import.meta.url))
	},
	{
		"id": "jsonc",
		"name": "JSON with Comments",
		"import": (() => __vitePreload(() => import("./jsonc-DwsmLKb7.js"), [], import.meta.url))
	},
	{
		"id": "jsonl",
		"name": "JSON Lines",
		"import": (() => __vitePreload(() => import("./jsonl-CaI638E3.js"), [], import.meta.url))
	},
	{
		"id": "jsonnet",
		"name": "Jsonnet",
		"import": (() => __vitePreload(() => import("./jsonnet-By52BiIi.js"), [], import.meta.url))
	},
	{
		"id": "jssm",
		"name": "JSSM",
		"aliases": ["fsl"],
		"import": (() => __vitePreload(() => import("./jssm-uP9_ed2V.js"), [], import.meta.url))
	},
	{
		"id": "jsx",
		"name": "JSX",
		"import": (() => __vitePreload(() => import("./jsx-CTYK6TV5.js"), __vite__mapDeps([84,44]), import.meta.url))
	},
	{
		"id": "julia",
		"name": "Julia",
		"aliases": ["jl"],
		"import": (() => __vitePreload(() => import("./julia-BN7uG_Fi.js"), __vite__mapDeps([85,21,29,30,31,17,4,23,86]), import.meta.url))
	},
	{
		"id": "kotlin",
		"name": "Kotlin",
		"aliases": ["kt", "kts"],
		"import": (() => __vitePreload(() => import("./kotlin-ChitXG-H.js"), [], import.meta.url))
	},
	{
		"id": "kusto",
		"name": "Kusto",
		"aliases": ["kql"],
		"import": (() => __vitePreload(() => import("./kusto-DtiyDqGe.js"), [], import.meta.url))
	},
	{
		"id": "latex",
		"name": "LaTeX",
		"import": (() => __vitePreload(() => import("./latex-Dp_gVk_D.js"), __vite__mapDeps([87,86,88]), import.meta.url))
	},
	{
		"id": "lean",
		"name": "Lean 4",
		"aliases": ["lean4"],
		"import": (() => __vitePreload(() => import("./lean-C8O1lbI7.js"), [], import.meta.url))
	},
	{
		"id": "less",
		"name": "Less",
		"import": (() => __vitePreload(() => import("./less-Eip8g5EN.js"), __vite__mapDeps([89,90]), import.meta.url))
	},
	{
		"id": "liquid",
		"name": "Liquid",
		"import": (() => __vitePreload(() => import("./liquid-D1eULOmS.js"), __vite__mapDeps([91,3,2,4,9]), import.meta.url))
	},
	{
		"id": "llvm",
		"name": "LLVM IR",
		"import": (() => __vitePreload(() => import("./llvm-BOnhXpcz.js"), [], import.meta.url))
	},
	{
		"id": "log",
		"name": "Log file",
		"import": (() => __vitePreload(() => import("./log-M0DxHwhj.js"), [], import.meta.url))
	},
	{
		"id": "logo",
		"name": "Logo",
		"import": (() => __vitePreload(() => import("./logo-2W8b2MGV.js"), [], import.meta.url))
	},
	{
		"id": "lua",
		"name": "Lua",
		"import": (() => __vitePreload(() => import("./lua-Pg-n4n4e.js"), __vite__mapDeps([92,21,46]), import.meta.url))
	},
	{
		"id": "luau",
		"name": "Luau",
		"import": (() => __vitePreload(() => import("./luau-COGyNXVX.js"), [], import.meta.url))
	},
	{
		"id": "make",
		"name": "Makefile",
		"aliases": ["makefile"],
		"import": (() => __vitePreload(() => import("./make-BvIDlvuu.js"), [], import.meta.url))
	},
	{
		"id": "markdown",
		"name": "Markdown",
		"aliases": ["md"],
		"import": (() => __vitePreload(() => import("./markdown-BfJUJqnE.js"), __vite__mapDeps([93,50]), import.meta.url))
	},
	{
		"id": "marko",
		"name": "Marko",
		"import": (() => __vitePreload(() => import("./marko-D0-nTItI.js"), __vite__mapDeps([94,3,90,6,14]), import.meta.url))
	},
	{
		"id": "matlab",
		"name": "MATLAB",
		"import": (() => __vitePreload(() => import("./matlab-BrS5IPnT.js"), [], import.meta.url))
	},
	{
		"id": "mdc",
		"name": "MDC",
		"import": (() => __vitePreload(() => import("./mdc-CfH0_wvs.js"), __vite__mapDeps([95,3,16,2,4,50,48]), import.meta.url))
	},
	{
		"id": "mdx",
		"name": "MDX",
		"import": (() => __vitePreload(() => import("./mdx-CIy14rl-.js"), [], import.meta.url))
	},
	{
		"id": "mermaid",
		"name": "Mermaid",
		"aliases": ["mmd"],
		"import": (() => __vitePreload(() => import("./mermaid-6UzalXHz.js"), [], import.meta.url))
	},
	{
		"id": "mipsasm",
		"name": "MIPS Assembly",
		"aliases": ["mips"],
		"import": (() => __vitePreload(() => import("./mipsasm-qxTIA3lj.js"), [], import.meta.url))
	},
	{
		"id": "mojo",
		"name": "Mojo",
		"import": (() => __vitePreload(() => import("./mojo-ud3IYo4D.js"), [], import.meta.url))
	},
	{
		"id": "move",
		"name": "Move",
		"import": (() => __vitePreload(() => import("./move-CQN4hOwI.js"), [], import.meta.url))
	},
	{
		"id": "narrat",
		"name": "Narrat Language",
		"aliases": ["nar"],
		"import": (() => __vitePreload(() => import("./narrat-h7BlbSwY.js"), [], import.meta.url))
	},
	{
		"id": "nextflow",
		"name": "Nextflow",
		"aliases": ["nf"],
		"import": (() => __vitePreload(() => import("./nextflow-BtCIP60B.js"), [], import.meta.url))
	},
	{
		"id": "nginx",
		"name": "Nginx",
		"import": (() => __vitePreload(() => import("./nginx-Tadh9eQs.js"), __vite__mapDeps([96,21,46]), import.meta.url))
	},
	{
		"id": "nim",
		"name": "Nim",
		"import": (() => __vitePreload(() => import("./nim-BIoXls5U.js"), __vite__mapDeps([97,21,3,30,2,4,8,50,10]), import.meta.url))
	},
	{
		"id": "nix",
		"name": "Nix",
		"import": (() => __vitePreload(() => import("./nix-CHvC8vwc.js"), [], import.meta.url))
	},
	{
		"id": "nushell",
		"name": "nushell",
		"aliases": ["nu"],
		"import": (() => __vitePreload(() => import("./nushell-ACjIcWcj.js"), [], import.meta.url))
	},
	{
		"id": "objective-c",
		"name": "Objective-C",
		"aliases": ["objc"],
		"import": (() => __vitePreload(() => import("./objective-c-CbmswqKv.js"), [], import.meta.url))
	},
	{
		"id": "objective-cpp",
		"name": "Objective-C++",
		"import": (() => __vitePreload(() => import("./objective-cpp-CIeX4jlI.js"), [], import.meta.url))
	},
	{
		"id": "ocaml",
		"name": "OCaml",
		"import": (() => __vitePreload(() => import("./ocaml-DduePvyX.js"), [], import.meta.url))
	},
	{
		"id": "pascal",
		"name": "Pascal",
		"import": (() => __vitePreload(() => import("./pascal-Cz5jW64A.js"), [], import.meta.url))
	},
	{
		"id": "perl",
		"name": "Perl",
		"import": (() => __vitePreload(() => import("./perl-DFR5-V1b.js"), __vite__mapDeps([98,3,2,4,8,17,10]), import.meta.url))
	},
	{
		"id": "php",
		"name": "PHP",
		"import": (() => __vitePreload(() => import("./php-BHsUzYFb.js"), __vite__mapDeps([99,3,2,4,8,9,100,17,10]), import.meta.url))
	},
	{
		"id": "plsql",
		"name": "PL/SQL",
		"import": (() => __vitePreload(() => import("./plsql-CI0lP_UD.js"), [], import.meta.url))
	},
	{
		"id": "po",
		"name": "Gettext PO",
		"aliases": ["pot", "potx"],
		"import": (() => __vitePreload(() => import("./po-DR8SHLOT.js"), [], import.meta.url))
	},
	{
		"id": "polar",
		"name": "Polar",
		"import": (() => __vitePreload(() => import("./polar-zVNNoRPd.js"), [], import.meta.url))
	},
	{
		"id": "postcss",
		"name": "PostCSS",
		"import": (() => __vitePreload(() => import("./postcss-BHjr3rob.js"), __vite__mapDeps([101,12]), import.meta.url))
	},
	{
		"id": "powerquery",
		"name": "PowerQuery",
		"import": (() => __vitePreload(() => import("./powerquery-BhVoWa5C.js"), [], import.meta.url))
	},
	{
		"id": "powershell",
		"name": "PowerShell",
		"aliases": ["ps", "ps1"],
		"import": (() => __vitePreload(() => import("./powershell-gKxrNUWx.js"), [], import.meta.url))
	},
	{
		"id": "prisma",
		"name": "Prisma",
		"import": (() => __vitePreload(() => import("./prisma-CZULiJgY.js"), [], import.meta.url))
	},
	{
		"id": "prolog",
		"name": "Prolog",
		"import": (() => __vitePreload(() => import("./prolog-CiqQ0N5D.js"), [], import.meta.url))
	},
	{
		"id": "proto",
		"name": "Protocol Buffer 3",
		"aliases": ["protobuf"],
		"import": (() => __vitePreload(() => import("./proto-C_GIR9H8.js"), [], import.meta.url))
	},
	{
		"id": "pug",
		"name": "Pug",
		"aliases": ["jade"],
		"import": (() => __vitePreload(() => import("./pug-B8nWteL_.js"), __vite__mapDeps([102,3,2,4]), import.meta.url))
	},
	{
		"id": "puppet",
		"name": "Puppet",
		"import": (() => __vitePreload(() => import("./puppet-BB6-e1lY.js"), [], import.meta.url))
	},
	{
		"id": "purescript",
		"name": "PureScript",
		"import": (() => __vitePreload(() => import("./purescript-BjwSkcGs.js"), [], import.meta.url))
	},
	{
		"id": "python",
		"name": "Python",
		"aliases": ["py"],
		"import": (() => __vitePreload(() => import("./python-BqTxEWde.js"), __vite__mapDeps([103,23]), import.meta.url))
	},
	{
		"id": "qml",
		"name": "QML",
		"import": (() => __vitePreload(() => import("./qml-DyB232Ot.js"), __vite__mapDeps([104,4]), import.meta.url))
	},
	{
		"id": "qmldir",
		"name": "QML Directory",
		"import": (() => __vitePreload(() => import("./qmldir-DT0RJFRO.js"), [], import.meta.url))
	},
	{
		"id": "qss",
		"name": "Qt Style Sheets",
		"import": (() => __vitePreload(() => import("./qss-BJqkRTQj.js"), [], import.meta.url))
	},
	{
		"id": "r",
		"name": "R",
		"import": (() => __vitePreload(() => import("./r-CuOiyelf.js"), __vite__mapDeps([105,86]), import.meta.url))
	},
	{
		"id": "racket",
		"name": "Racket",
		"import": (() => __vitePreload(() => import("./racket-Cgl2d8l2.js"), [], import.meta.url))
	},
	{
		"id": "raku",
		"name": "Raku",
		"aliases": ["perl6"],
		"import": (() => __vitePreload(() => import("./raku-CApMbo1N.js"), [], import.meta.url))
	},
	{
		"id": "razor",
		"name": "ASP.NET Razor",
		"import": (() => __vitePreload(() => import("./razor-DmyyxmC7.js"), __vite__mapDeps([106,35,3,2,4]), import.meta.url))
	},
	{
		"id": "reg",
		"name": "Windows Registry Script",
		"import": (() => __vitePreload(() => import("./reg-DJZba03J.js"), [], import.meta.url))
	},
	{
		"id": "regexp",
		"name": "RegExp",
		"aliases": ["regex"],
		"import": (() => __vitePreload(() => import("./regexp-CqiqKJVB.js"), __vite__mapDeps([107,31]), import.meta.url))
	},
	{
		"id": "rel",
		"name": "Rel",
		"import": (() => __vitePreload(() => import("./rel-DBtCWAzb.js"), [], import.meta.url))
	},
	{
		"id": "riscv",
		"name": "RISC-V",
		"import": (() => __vitePreload(() => import("./riscv-CCO0RL7A.js"), [], import.meta.url))
	},
	{
		"id": "rst",
		"name": "reStructuredText",
		"import": (() => __vitePreload(() => import("./rst-BCtvVUMe.js"), __vite__mapDeps([108,21,25,29,30,31,17,3,43,4,44,13,14,45,16,2,8,46,23,47,33,10,48]), import.meta.url))
	},
	{
		"id": "ruby",
		"name": "Ruby",
		"aliases": ["rb"],
		"import": (() => __vitePreload(() => import("./ruby-ChM1EpzV.js"), __vite__mapDeps([109,21,29,30,31,17,3,43,4,44,13,14,45,2,8,46,47,33,10,48]), import.meta.url))
	},
	{
		"id": "rust",
		"name": "Rust",
		"aliases": ["rs"],
		"import": (() => __vitePreload(() => import("./rust-B1gDnBfc.js"), [], import.meta.url))
	},
	{
		"id": "sas",
		"name": "SAS",
		"import": (() => __vitePreload(() => import("./sas-DDtYYxyD.js"), __vite__mapDeps([110,17]), import.meta.url))
	},
	{
		"id": "sass",
		"name": "Sass",
		"import": (() => __vitePreload(() => import("./sass-CZxu0crg.js"), [], import.meta.url))
	},
	{
		"id": "scala",
		"name": "Scala",
		"import": (() => __vitePreload(() => import("./scala-BiGkf5gG.js"), [], import.meta.url))
	},
	{
		"id": "scheme",
		"name": "Scheme",
		"import": (() => __vitePreload(() => import("./scheme-CRgKCa2H.js"), [], import.meta.url))
	},
	{
		"id": "scss",
		"name": "SCSS",
		"import": (() => __vitePreload(() => import("./scss-FVUDPqDe.js"), __vite__mapDeps([111,3,6]), import.meta.url))
	},
	{
		"id": "sdbl",
		"name": "1C (Query)",
		"aliases": ["1c-query"],
		"import": (() => __vitePreload(() => import("./sdbl-D6OWllNc.js"), __vite__mapDeps([112,19]), import.meta.url))
	},
	{
		"id": "shaderlab",
		"name": "ShaderLab",
		"aliases": ["shader"],
		"import": (() => __vitePreload(() => import("./shaderlab-jWnaqKN_.js"), __vite__mapDeps([113,74]), import.meta.url))
	},
	{
		"id": "shellscript",
		"name": "Shell",
		"aliases": [
			"bash",
			"sh",
			"shell",
			"zsh"
		],
		"import": (() => __vitePreload(() => import("./shellscript-BUtKaIzA.js"), __vite__mapDeps([114,33]), import.meta.url))
	},
	{
		"id": "shellsession",
		"name": "Shell Session",
		"aliases": ["console"],
		"import": (() => __vitePreload(() => import("./shellsession-DD9B_uJ9.js"), __vite__mapDeps([115,33]), import.meta.url))
	},
	{
		"id": "smalltalk",
		"name": "Smalltalk",
		"import": (() => __vitePreload(() => import("./smalltalk-CsDOAPCc.js"), [], import.meta.url))
	},
	{
		"id": "solidity",
		"name": "Solidity",
		"import": (() => __vitePreload(() => import("./solidity-BYR_xhRp.js"), [], import.meta.url))
	},
	{
		"id": "soy",
		"name": "Closure Templates",
		"aliases": ["closure-templates"],
		"import": (() => __vitePreload(() => import("./soy-BIHeIn1W.js"), __vite__mapDeps([116,3,2,4]), import.meta.url))
	},
	{
		"id": "sparql",
		"name": "SPARQL",
		"import": (() => __vitePreload(() => import("./sparql-4oLOD8Ww.js"), __vite__mapDeps([117,118]), import.meta.url))
	},
	{
		"id": "splunk",
		"name": "Splunk Query Language",
		"aliases": ["spl"],
		"import": (() => __vitePreload(() => import("./splunk-2CnEGpYs.js"), [], import.meta.url))
	},
	{
		"id": "sql",
		"name": "SQL",
		"import": (() => __vitePreload(() => import("./sql-8c5I0h2b.js"), __vite__mapDeps([119,17]), import.meta.url))
	},
	{
		"id": "ssh-config",
		"name": "SSH Config",
		"import": (() => __vitePreload(() => import("./ssh-config-Cax8w8Pe.js"), [], import.meta.url))
	},
	{
		"id": "stata",
		"name": "Stata",
		"import": (() => __vitePreload(() => import("./stata-DTDkE664.js"), __vite__mapDeps([120,17]), import.meta.url))
	},
	{
		"id": "stylus",
		"name": "Stylus",
		"aliases": ["styl"],
		"import": (() => __vitePreload(() => import("./stylus-DJYkuzJ1.js"), __vite__mapDeps([121,122]), import.meta.url))
	},
	{
		"id": "svelte",
		"name": "Svelte",
		"import": (() => __vitePreload(() => import("./svelte-D31aakhX.js"), __vite__mapDeps([123,3,4,12,14]), import.meta.url))
	},
	{
		"id": "swift",
		"name": "Swift",
		"import": (() => __vitePreload(() => import("./swift-BkomxQma.js"), [], import.meta.url))
	},
	{
		"id": "system-verilog",
		"name": "SystemVerilog",
		"import": (() => __vitePreload(() => import("./system-verilog-BtTn7XNb.js"), [], import.meta.url))
	},
	{
		"id": "systemd",
		"name": "Systemd Units",
		"import": (() => __vitePreload(() => import("./systemd-OEVMhBzN.js"), [], import.meta.url))
	},
	{
		"id": "talonscript",
		"name": "TalonScript",
		"aliases": ["talon"],
		"import": (() => __vitePreload(() => import("./talonscript-DN1z4vWr.js"), [], import.meta.url))
	},
	{
		"id": "tasl",
		"name": "Tasl",
		"import": (() => __vitePreload(() => import("./tasl-C8Z6tAMM.js"), [], import.meta.url))
	},
	{
		"id": "tcl",
		"name": "Tcl",
		"import": (() => __vitePreload(() => import("./tcl-Dg-Od1nV.js"), [], import.meta.url))
	},
	{
		"id": "templ",
		"name": "Templ",
		"import": (() => __vitePreload(() => import("./templ-DEmykQRU.js"), __vite__mapDeps([124,3,66,4]), import.meta.url))
	},
	{
		"id": "terraform",
		"name": "Terraform",
		"aliases": ["tf", "tfvars"],
		"import": (() => __vitePreload(() => import("./terraform-gzbpbWeT.js"), [], import.meta.url))
	},
	{
		"id": "tex",
		"name": "TeX",
		"import": (() => __vitePreload(() => import("./tex-9hE2MvTu.js"), __vite__mapDeps([125,86,88]), import.meta.url))
	},
	{
		"id": "toml",
		"name": "TOML",
		"import": (() => __vitePreload(() => import("./toml-D1yN8lue.js"), [], import.meta.url))
	},
	{
		"id": "ts-tags",
		"name": "TypeScript with Tags",
		"aliases": ["lit"],
		"import": (() => __vitePreload(() => import("./ts-tags-DGNBrDF6.js"), __vite__mapDeps([126,21,3,30,2,4,8,17,14,10]), import.meta.url))
	},
	{
		"id": "tsv",
		"name": "TSV",
		"import": (() => __vitePreload(() => import("./tsv-RrSQpSA1.js"), [], import.meta.url))
	},
	{
		"id": "tsx",
		"name": "TSX",
		"import": (() => __vitePreload(() => import("./tsx-B3_GyDhV.js"), __vite__mapDeps([127,13]), import.meta.url))
	},
	{
		"id": "turtle",
		"name": "Turtle",
		"import": (() => __vitePreload(() => import("./turtle-CK1facO0.js"), __vite__mapDeps([128,118]), import.meta.url))
	},
	{
		"id": "twig",
		"name": "Twig",
		"import": (() => __vitePreload(() => import("./twig-CNwzHCmG.js"), __vite__mapDeps([129,21,29,30,31,17,3,43,4,44,13,14,45,2,8,9,46,100,10,23,47,33,48,6]), import.meta.url))
	},
	{
		"id": "typescript",
		"name": "TypeScript",
		"aliases": ["ts"],
		"import": (() => __vitePreload(() => import("./typescript-UDgxddJj.js"), __vite__mapDeps([130,14]), import.meta.url))
	},
	{
		"id": "typespec",
		"name": "TypeSpec",
		"aliases": ["tsp"],
		"import": (() => __vitePreload(() => import("./typespec-CR81uooT.js"), [], import.meta.url))
	},
	{
		"id": "typst",
		"name": "Typst",
		"aliases": ["typ"],
		"import": (() => __vitePreload(() => import("./typst-Np8bqWdZ.js"), [], import.meta.url))
	},
	{
		"id": "v",
		"name": "V",
		"import": (() => __vitePreload(() => import("./v-B3QnTnyl.js"), [], import.meta.url))
	},
	{
		"id": "vala",
		"name": "Vala",
		"import": (() => __vitePreload(() => import("./vala-Dm6BUwZ0.js"), [], import.meta.url))
	},
	{
		"id": "vb",
		"name": "Visual Basic",
		"aliases": ["cmd"],
		"import": (() => __vitePreload(() => import("./vb-DFbn1qDN.js"), [], import.meta.url))
	},
	{
		"id": "verilog",
		"name": "Verilog",
		"import": (() => __vitePreload(() => import("./verilog-QRyS64rw.js"), [], import.meta.url))
	},
	{
		"id": "vhdl",
		"name": "VHDL",
		"import": (() => __vitePreload(() => import("./vhdl-O-6_PEKb.js"), [], import.meta.url))
	},
	{
		"id": "viml",
		"name": "Vim Script",
		"aliases": ["vim", "vimscript"],
		"import": (() => __vitePreload(() => import("./viml-vQiAq2C4.js"), [], import.meta.url))
	},
	{
		"id": "vue",
		"name": "Vue",
		"import": (() => __vitePreload(() => import("./vue-BnBnusap.js"), __vite__mapDeps([131,3,16,2,4,9,132,14]), import.meta.url))
	},
	{
		"id": "vue-html",
		"name": "Vue HTML",
		"import": (() => __vitePreload(() => import("./vue-html-C_QqBuYj.js"), __vite__mapDeps([133,3,16,2,4,9,132,14]), import.meta.url))
	},
	{
		"id": "vue-vine",
		"name": "Vue Vine",
		"import": (() => __vitePreload(() => import("./vue-vine-D1nUkunW.js"), __vite__mapDeps([134,3,16,2,4,9,90,132,14,12,6,122]), import.meta.url))
	},
	{
		"id": "vyper",
		"name": "Vyper",
		"aliases": ["vy"],
		"import": (() => __vitePreload(() => import("./vyper-EJtFC47O.js"), [], import.meta.url))
	},
	{
		"id": "wasm",
		"name": "WebAssembly",
		"import": (() => __vitePreload(() => import("./wasm-Bid1fssb.js"), [], import.meta.url))
	},
	{
		"id": "wenyan",
		"name": "Wenyan",
		"aliases": ["文言"],
		"import": (() => __vitePreload(() => import("./wenyan-CJfG2U9D.js"), [], import.meta.url))
	},
	{
		"id": "wgsl",
		"name": "WGSL",
		"import": (() => __vitePreload(() => import("./wgsl-Cr-ZQQ6E.js"), [], import.meta.url))
	},
	{
		"id": "wikitext",
		"name": "Wikitext",
		"aliases": ["mediawiki", "wiki"],
		"import": (() => __vitePreload(() => import("./wikitext-iM0e8J9P.js"), [], import.meta.url))
	},
	{
		"id": "wit",
		"name": "WebAssembly Interface Types",
		"import": (() => __vitePreload(() => import("./wit-fAE9gjD_.js"), [], import.meta.url))
	},
	{
		"id": "wolfram",
		"name": "Wolfram",
		"aliases": ["wl"],
		"import": (() => __vitePreload(() => import("./wolfram-Vdup0Vq8.js"), [], import.meta.url))
	},
	{
		"id": "xml",
		"name": "XML",
		"import": (() => __vitePreload(() => import("./xml-B9zrtOkV.js"), __vite__mapDeps([135,8,10]), import.meta.url))
	},
	{
		"id": "xsl",
		"name": "XSL",
		"import": (() => __vitePreload(() => import("./xsl-CTM_gp5m.js"), __vite__mapDeps([136,8,10]), import.meta.url))
	},
	{
		"id": "yaml",
		"name": "YAML",
		"aliases": ["yml"],
		"import": (() => __vitePreload(() => import("./yaml-Du6PPDFW.js"), __vite__mapDeps([137,48]), import.meta.url))
	},
	{
		"id": "zenscript",
		"name": "ZenScript",
		"import": (() => __vitePreload(() => import("./zenscript-W5GnJ3lp.js"), [], import.meta.url))
	},
	{
		"id": "zig",
		"name": "Zig",
		"import": (() => __vitePreload(() => import("./zig-CLAkVpV1.js"), [], import.meta.url))
	}
];
const bundledLanguagesBase = Object.fromEntries(bundledLanguagesInfo.map((i$1) => [i$1.id, i$1.import]));
const bundledLanguagesAlias = Object.fromEntries(bundledLanguagesInfo.flatMap((i$1) => i$1.aliases?.map((a$1) => [a$1, i$1.import]) || []));
const bundledLanguages = {
	...bundledLanguagesBase,
	...bundledLanguagesAlias
};
const bundledThemesInfo = [
	{
		"id": "andromeeda",
		"displayName": "Andromeeda",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./andromeeda-sbMe9qQM.js"), [], import.meta.url))
	},
	{
		"id": "aurora-x",
		"displayName": "Aurora X",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./aurora-x-8pkrXOkH.js"), [], import.meta.url))
	},
	{
		"id": "ayu-dark",
		"displayName": "Ayu Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./ayu-dark-PZfONZWO.js"), [], import.meta.url))
	},
	{
		"id": "catppuccin-frappe",
		"displayName": "Catppuccin Frappé",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./catppuccin-frappe-CifiVv7k.js"), [], import.meta.url))
	},
	{
		"id": "catppuccin-latte",
		"displayName": "Catppuccin Latte",
		"type": "light",
		"import": (() => __vitePreload(() => import("./catppuccin-latte-CZ7DdxOL.js"), [], import.meta.url))
	},
	{
		"id": "catppuccin-macchiato",
		"displayName": "Catppuccin Macchiato",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./catppuccin-macchiato-CJKXVCDu.js"), [], import.meta.url))
	},
	{
		"id": "catppuccin-mocha",
		"displayName": "Catppuccin Mocha",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./catppuccin-mocha-BAWPyF7n.js"), [], import.meta.url))
	},
	{
		"id": "dark-plus",
		"displayName": "Dark Plus",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./dark-plus-DacP804m.js"), [], import.meta.url))
	},
	{
		"id": "dracula",
		"displayName": "Dracula Theme",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./dracula-CHka1Ex3.js"), [], import.meta.url))
	},
	{
		"id": "dracula-soft",
		"displayName": "Dracula Theme Soft",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./dracula-soft-D234Cji0.js"), [], import.meta.url))
	},
	{
		"id": "everforest-dark",
		"displayName": "Everforest Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./everforest-dark-CLRBH6sh.js"), [], import.meta.url))
	},
	{
		"id": "everforest-light",
		"displayName": "Everforest Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./everforest-light-FnJEC5Qr.js"), [], import.meta.url))
	},
	{
		"id": "github-dark",
		"displayName": "GitHub Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./github-dark-DSsFbFvV.js"), [], import.meta.url))
	},
	{
		"id": "github-dark-default",
		"displayName": "GitHub Dark Default",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./github-dark-default-Cy8j3CqJ.js"), [], import.meta.url))
	},
	{
		"id": "github-dark-dimmed",
		"displayName": "GitHub Dark Dimmed",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./github-dark-dimmed-b8I6jCq-.js"), [], import.meta.url))
	},
	{
		"id": "github-dark-high-contrast",
		"displayName": "GitHub Dark High Contrast",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./github-dark-high-contrast-oaiwcd8c.js"), [], import.meta.url))
	},
	{
		"id": "github-light",
		"displayName": "GitHub Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./github-light-BCmzQ5dm.js"), [], import.meta.url))
	},
	{
		"id": "github-light-default",
		"displayName": "GitHub Light Default",
		"type": "light",
		"import": (() => __vitePreload(() => import("./github-light-default-C3176-br.js"), [], import.meta.url))
	},
	{
		"id": "github-light-high-contrast",
		"displayName": "GitHub Light High Contrast",
		"type": "light",
		"import": (() => __vitePreload(() => import("./github-light-high-contrast-BuQHXRWH.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-dark-hard",
		"displayName": "Gruvbox Dark Hard",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./gruvbox-dark-hard-B6Bq02RO.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-dark-medium",
		"displayName": "Gruvbox Dark Medium",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./gruvbox-dark-medium-BqULonQH.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-dark-soft",
		"displayName": "Gruvbox Dark Soft",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./gruvbox-dark-soft-CF4IEi9E.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-light-hard",
		"displayName": "Gruvbox Light Hard",
		"type": "light",
		"import": (() => __vitePreload(() => import("./gruvbox-light-hard-CBPlh1bd.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-light-medium",
		"displayName": "Gruvbox Light Medium",
		"type": "light",
		"import": (() => __vitePreload(() => import("./gruvbox-light-medium-DzsEmSkx.js"), [], import.meta.url))
	},
	{
		"id": "gruvbox-light-soft",
		"displayName": "Gruvbox Light Soft",
		"type": "light",
		"import": (() => __vitePreload(() => import("./gruvbox-light-soft-C_F3phbR.js"), [], import.meta.url))
	},
	{
		"id": "houston",
		"displayName": "Houston",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./houston-BzqlNveZ.js"), [], import.meta.url))
	},
	{
		"id": "kanagawa-dragon",
		"displayName": "Kanagawa Dragon",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./kanagawa-dragon-C8XN7ZLe.js"), [], import.meta.url))
	},
	{
		"id": "kanagawa-lotus",
		"displayName": "Kanagawa Lotus",
		"type": "light",
		"import": (() => __vitePreload(() => import("./kanagawa-lotus-DwpRVutF.js"), [], import.meta.url))
	},
	{
		"id": "kanagawa-wave",
		"displayName": "Kanagawa Wave",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./kanagawa-wave-DDdXE54l.js"), [], import.meta.url))
	},
	{
		"id": "laserwave",
		"displayName": "LaserWave",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./laserwave-zfmFNu6z.js"), [], import.meta.url))
	},
	{
		"id": "light-plus",
		"displayName": "Light Plus",
		"type": "light",
		"import": (() => __vitePreload(() => import("./light-plus-Bl1vjQpw.js"), [], import.meta.url))
	},
	{
		"id": "material-theme",
		"displayName": "Material Theme",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./material-theme-CEeMO6Vw.js"), [], import.meta.url))
	},
	{
		"id": "material-theme-darker",
		"displayName": "Material Theme Darker",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./material-theme-darker-CCrkxRsr.js"), [], import.meta.url))
	},
	{
		"id": "material-theme-lighter",
		"displayName": "Material Theme Lighter",
		"type": "light",
		"import": (() => __vitePreload(() => import("./material-theme-lighter-OJZymlun.js"), [], import.meta.url))
	},
	{
		"id": "material-theme-ocean",
		"displayName": "Material Theme Ocean",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./material-theme-ocean-BBY5XsjS.js"), [], import.meta.url))
	},
	{
		"id": "material-theme-palenight",
		"displayName": "Material Theme Palenight",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./material-theme-palenight-CNdFs8f-.js"), [], import.meta.url))
	},
	{
		"id": "min-dark",
		"displayName": "Min Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./min-dark-BcsT6584.js"), [], import.meta.url))
	},
	{
		"id": "min-light",
		"displayName": "Min Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./min-light-DHuWRLHf.js"), [], import.meta.url))
	},
	{
		"id": "monokai",
		"displayName": "Monokai",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./monokai-Dco8o1d9.js"), [], import.meta.url))
	},
	{
		"id": "night-owl",
		"displayName": "Night Owl",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./night-owl-CyPVcZYR.js"), [], import.meta.url))
	},
	{
		"id": "nord",
		"displayName": "Nord",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./nord-Dc6rLWK_.js"), [], import.meta.url))
	},
	{
		"id": "one-dark-pro",
		"displayName": "One Dark Pro",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./one-dark-pro-Cb7pxgx0.js"), [], import.meta.url))
	},
	{
		"id": "one-light",
		"displayName": "One Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./one-light-CIwMGoVe.js"), [], import.meta.url))
	},
	{
		"id": "plastic",
		"displayName": "Plastic",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./plastic-Ddw1UhN8.js"), [], import.meta.url))
	},
	{
		"id": "poimandres",
		"displayName": "Poimandres",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./poimandres-C2_QbpYK.js"), [], import.meta.url))
	},
	{
		"id": "red",
		"displayName": "Red",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./red-StW8Rv1V.js"), [], import.meta.url))
	},
	{
		"id": "rose-pine",
		"displayName": "Rosé Pine",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./rose-pine-B8_O__km.js"), [], import.meta.url))
	},
	{
		"id": "rose-pine-dawn",
		"displayName": "Rosé Pine Dawn",
		"type": "light",
		"import": (() => __vitePreload(() => import("./rose-pine-dawn-D5DU4c35.js"), [], import.meta.url))
	},
	{
		"id": "rose-pine-moon",
		"displayName": "Rosé Pine Moon",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./rose-pine-moon-DSPLNP_O.js"), [], import.meta.url))
	},
	{
		"id": "slack-dark",
		"displayName": "Slack Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./slack-dark-DYSuIsP6.js"), [], import.meta.url))
	},
	{
		"id": "slack-ochin",
		"displayName": "Slack Ochin",
		"type": "light",
		"import": (() => __vitePreload(() => import("./slack-ochin-DFGQO1X0.js"), [], import.meta.url))
	},
	{
		"id": "snazzy-light",
		"displayName": "Snazzy Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./snazzy-light-DiLRQwwd.js"), [], import.meta.url))
	},
	{
		"id": "solarized-dark",
		"displayName": "Solarized Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./solarized-dark-Bh2T7loO.js"), [], import.meta.url))
	},
	{
		"id": "solarized-light",
		"displayName": "Solarized Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./solarized-light-DveZxcXY.js"), [], import.meta.url))
	},
	{
		"id": "synthwave-84",
		"displayName": "Synthwave '84",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./synthwave-84-YvDXLi6r.js"), [], import.meta.url))
	},
	{
		"id": "tokyo-night",
		"displayName": "Tokyo Night",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./tokyo-night-MqZBDES9.js"), [], import.meta.url))
	},
	{
		"id": "vesper",
		"displayName": "Vesper",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./vesper-VhyXs982.js"), [], import.meta.url))
	},
	{
		"id": "vitesse-black",
		"displayName": "Vitesse Black",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./vitesse-black-LWmC3HhJ.js"), [], import.meta.url))
	},
	{
		"id": "vitesse-dark",
		"displayName": "Vitesse Dark",
		"type": "dark",
		"import": (() => __vitePreload(() => import("./vitesse-dark-B1t7A8oI.js"), [], import.meta.url))
	},
	{
		"id": "vitesse-light",
		"displayName": "Vitesse Light",
		"type": "light",
		"import": (() => __vitePreload(() => import("./vitesse-light-D_X4arfq.js"), [], import.meta.url))
	}
];
const bundledThemes = Object.fromEntries(bundledThemesInfo.map((i$1) => [i$1.id, i$1.import]));
var ShikiError$1 = class extends Error {
	constructor(message) {
		super(message);
		this.name = "ShikiError";
	}
};
function getHeapMax() {
	return 2147483648;
}
function _emscripten_get_now() {
	return typeof performance !== "undefined" ? performance.now() : Date.now();
}
const alignUp = (x$1, multiple) => x$1 + (multiple - x$1 % multiple) % multiple;
async function main(init) {
	let wasmMemory;
	let buffer;
	const binding = {};
	function updateGlobalBufferAndViews(buf) {
		buffer = buf;
		binding.HEAPU8 = new Uint8Array(buf);
		binding.HEAPU32 = new Uint32Array(buf);
	}
	function _emscripten_memcpy_big(dest, src, num) {
		binding.HEAPU8.copyWithin(dest, src, src + num);
	}
	function emscripten_realloc_buffer(size) {
		try {
			wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
			updateGlobalBufferAndViews(wasmMemory.buffer);
			return 1;
		} catch {}
	}
	function _emscripten_resize_heap(requestedSize) {
		const oldSize = binding.HEAPU8.length;
		requestedSize = requestedSize >>> 0;
		const maxHeapSize = getHeapMax();
		if (requestedSize > maxHeapSize) return false;
		for (let cutDown = 1; cutDown <= 4; cutDown *= 2) {
			let overGrownHeapSize = oldSize * (1 + .2 / cutDown);
			overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
			const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
			const replacement = emscripten_realloc_buffer(newSize);
			if (replacement) return true;
		}
		return false;
	}
	const UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
	function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead = 1024) {
		const endIdx = idx + maxBytesToRead;
		let endPtr = idx;
		while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
		if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
		let str = "";
		while (idx < endPtr) {
			let u0 = heapOrArray[idx++];
			if (!(u0 & 128)) {
				str += String.fromCharCode(u0);
				continue;
			}
			const u1 = heapOrArray[idx++] & 63;
			if ((u0 & 224) === 192) {
				str += String.fromCharCode((u0 & 31) << 6 | u1);
				continue;
			}
			const u2 = heapOrArray[idx++] & 63;
			if ((u0 & 240) === 224) u0 = (u0 & 15) << 12 | u1 << 6 | u2;
			else u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
			if (u0 < 65536) str += String.fromCharCode(u0);
			else {
				const ch = u0 - 65536;
				str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
			}
		}
		return str;
	}
	function UTF8ToString(ptr, maxBytesToRead) {
		return ptr ? UTF8ArrayToString(binding.HEAPU8, ptr, maxBytesToRead) : "";
	}
	const asmLibraryArg = {
		emscripten_get_now: _emscripten_get_now,
		emscripten_memcpy_big: _emscripten_memcpy_big,
		emscripten_resize_heap: _emscripten_resize_heap,
		fd_write: () => 0
	};
	async function createWasm() {
		const info = {
			env: asmLibraryArg,
			wasi_snapshot_preview1: asmLibraryArg
		};
		const exports = await init(info);
		wasmMemory = exports.memory;
		updateGlobalBufferAndViews(wasmMemory.buffer);
		Object.assign(binding, exports);
		binding.UTF8ToString = UTF8ToString;
	}
	await createWasm();
	return binding;
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
	enumerable: true,
	configurable: true,
	writable: true,
	value
}) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let onigBinding = null;
function throwLastOnigError(onigBinding2) {
	throw new ShikiError$1(onigBinding2.UTF8ToString(onigBinding2.getLastOnigError()));
}
var UtfString = class UtfString {
	constructor(str) {
		__publicField(this, "utf16Length");
		__publicField(this, "utf8Length");
		__publicField(this, "utf16Value");
		__publicField(this, "utf8Value");
		__publicField(this, "utf16OffsetToUtf8");
		__publicField(this, "utf8OffsetToUtf16");
		const utf16Length = str.length;
		const utf8Length = UtfString._utf8ByteLength(str);
		const computeIndicesMapping = utf8Length !== utf16Length;
		const utf16OffsetToUtf8 = computeIndicesMapping ? new Uint32Array(utf16Length + 1) : null;
		if (computeIndicesMapping) utf16OffsetToUtf8[utf16Length] = utf8Length;
		const utf8OffsetToUtf16 = computeIndicesMapping ? new Uint32Array(utf8Length + 1) : null;
		if (computeIndicesMapping) utf8OffsetToUtf16[utf8Length] = utf16Length;
		const utf8Value = new Uint8Array(utf8Length);
		let i8 = 0;
		for (let i16 = 0; i16 < utf16Length; i16++) {
			const charCode = str.charCodeAt(i16);
			let codePoint = charCode;
			let wasSurrogatePair = false;
			if (charCode >= 55296 && charCode <= 56319) {
				if (i16 + 1 < utf16Length) {
					const nextCharCode = str.charCodeAt(i16 + 1);
					if (nextCharCode >= 56320 && nextCharCode <= 57343) {
						codePoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
						wasSurrogatePair = true;
					}
				}
			}
			if (computeIndicesMapping) {
				utf16OffsetToUtf8[i16] = i8;
				if (wasSurrogatePair) utf16OffsetToUtf8[i16 + 1] = i8;
				if (codePoint <= 127) utf8OffsetToUtf16[i8 + 0] = i16;
				else if (codePoint <= 2047) {
					utf8OffsetToUtf16[i8 + 0] = i16;
					utf8OffsetToUtf16[i8 + 1] = i16;
				} else if (codePoint <= 65535) {
					utf8OffsetToUtf16[i8 + 0] = i16;
					utf8OffsetToUtf16[i8 + 1] = i16;
					utf8OffsetToUtf16[i8 + 2] = i16;
				} else {
					utf8OffsetToUtf16[i8 + 0] = i16;
					utf8OffsetToUtf16[i8 + 1] = i16;
					utf8OffsetToUtf16[i8 + 2] = i16;
					utf8OffsetToUtf16[i8 + 3] = i16;
				}
			}
			if (codePoint <= 127) utf8Value[i8++] = codePoint;
			else if (codePoint <= 2047) {
				utf8Value[i8++] = 192 | (codePoint & 1984) >>> 6;
				utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
			} else if (codePoint <= 65535) {
				utf8Value[i8++] = 224 | (codePoint & 61440) >>> 12;
				utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
				utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
			} else {
				utf8Value[i8++] = 240 | (codePoint & 1835008) >>> 18;
				utf8Value[i8++] = 128 | (codePoint & 258048) >>> 12;
				utf8Value[i8++] = 128 | (codePoint & 4032) >>> 6;
				utf8Value[i8++] = 128 | (codePoint & 63) >>> 0;
			}
			if (wasSurrogatePair) i16++;
		}
		this.utf16Length = utf16Length;
		this.utf8Length = utf8Length;
		this.utf16Value = str;
		this.utf8Value = utf8Value;
		this.utf16OffsetToUtf8 = utf16OffsetToUtf8;
		this.utf8OffsetToUtf16 = utf8OffsetToUtf16;
	}
	static _utf8ByteLength(str) {
		let result = 0;
		for (let i$1 = 0, len = str.length; i$1 < len; i$1++) {
			const charCode = str.charCodeAt(i$1);
			let codepoint = charCode;
			let wasSurrogatePair = false;
			if (charCode >= 55296 && charCode <= 56319) {
				if (i$1 + 1 < len) {
					const nextCharCode = str.charCodeAt(i$1 + 1);
					if (nextCharCode >= 56320 && nextCharCode <= 57343) {
						codepoint = (charCode - 55296 << 10) + 65536 | nextCharCode - 56320;
						wasSurrogatePair = true;
					}
				}
			}
			if (codepoint <= 127) result += 1;
			else if (codepoint <= 2047) result += 2;
			else if (codepoint <= 65535) result += 3;
			else result += 4;
			if (wasSurrogatePair) i$1++;
		}
		return result;
	}
	createString(onigBinding2) {
		const result = onigBinding2.omalloc(this.utf8Length);
		onigBinding2.HEAPU8.set(this.utf8Value, result);
		return result;
	}
};
const _OnigString = class _OnigString$1 {
	constructor(str) {
		__publicField(this, "id", ++_OnigString$1.LAST_ID);
		__publicField(this, "_onigBinding");
		__publicField(this, "content");
		__publicField(this, "utf16Length");
		__publicField(this, "utf8Length");
		__publicField(this, "utf16OffsetToUtf8");
		__publicField(this, "utf8OffsetToUtf16");
		__publicField(this, "ptr");
		if (!onigBinding) throw new ShikiError$1("Must invoke loadWasm first.");
		this._onigBinding = onigBinding;
		this.content = str;
		const utfString = new UtfString(str);
		this.utf16Length = utfString.utf16Length;
		this.utf8Length = utfString.utf8Length;
		this.utf16OffsetToUtf8 = utfString.utf16OffsetToUtf8;
		this.utf8OffsetToUtf16 = utfString.utf8OffsetToUtf16;
		if (this.utf8Length < 1e4 && !_OnigString$1._sharedPtrInUse) {
			if (!_OnigString$1._sharedPtr) _OnigString$1._sharedPtr = onigBinding.omalloc(1e4);
			_OnigString$1._sharedPtrInUse = true;
			onigBinding.HEAPU8.set(utfString.utf8Value, _OnigString$1._sharedPtr);
			this.ptr = _OnigString$1._sharedPtr;
		} else this.ptr = utfString.createString(onigBinding);
	}
	convertUtf8OffsetToUtf16(utf8Offset) {
		if (this.utf8OffsetToUtf16) {
			if (utf8Offset < 0) return 0;
			if (utf8Offset > this.utf8Length) return this.utf16Length;
			return this.utf8OffsetToUtf16[utf8Offset];
		}
		return utf8Offset;
	}
	convertUtf16OffsetToUtf8(utf16Offset) {
		if (this.utf16OffsetToUtf8) {
			if (utf16Offset < 0) return 0;
			if (utf16Offset > this.utf16Length) return this.utf8Length;
			return this.utf16OffsetToUtf8[utf16Offset];
		}
		return utf16Offset;
	}
	dispose() {
		if (this.ptr === _OnigString$1._sharedPtr) _OnigString$1._sharedPtrInUse = false;
		else this._onigBinding.ofree(this.ptr);
	}
};
__publicField(_OnigString, "LAST_ID", 0);
__publicField(_OnigString, "_sharedPtr", 0);
__publicField(_OnigString, "_sharedPtrInUse", false);
let OnigString = _OnigString;
var OnigScanner = class {
	constructor(patterns) {
		__publicField(this, "_onigBinding");
		__publicField(this, "_ptr");
		if (!onigBinding) throw new ShikiError$1("Must invoke loadWasm first.");
		const strPtrsArr = [];
		const strLenArr = [];
		for (let i$1 = 0, len = patterns.length; i$1 < len; i$1++) {
			const utfString = new UtfString(patterns[i$1]);
			strPtrsArr[i$1] = utfString.createString(onigBinding);
			strLenArr[i$1] = utfString.utf8Length;
		}
		const strPtrsPtr = onigBinding.omalloc(4 * patterns.length);
		onigBinding.HEAPU32.set(strPtrsArr, strPtrsPtr / 4);
		const strLenPtr = onigBinding.omalloc(4 * patterns.length);
		onigBinding.HEAPU32.set(strLenArr, strLenPtr / 4);
		const scannerPtr = onigBinding.createOnigScanner(strPtrsPtr, strLenPtr, patterns.length);
		for (let i$1 = 0, len = patterns.length; i$1 < len; i$1++) onigBinding.ofree(strPtrsArr[i$1]);
		onigBinding.ofree(strLenPtr);
		onigBinding.ofree(strPtrsPtr);
		if (scannerPtr === 0) throwLastOnigError(onigBinding);
		this._onigBinding = onigBinding;
		this._ptr = scannerPtr;
	}
	dispose() {
		this._onigBinding.freeOnigScanner(this._ptr);
	}
	findNextMatchSync(string, startPosition, arg) {
		let options = 0;
		if (typeof arg === "number") options = arg;
		if (typeof string === "string") {
			string = new OnigString(string);
			const result = this._findNextMatchSync(string, startPosition, false, options);
			string.dispose();
			return result;
		}
		return this._findNextMatchSync(string, startPosition, false, options);
	}
	_findNextMatchSync(string, startPosition, debugCall, options) {
		const onigBinding2 = this._onigBinding;
		const resultPtr = onigBinding2.findNextOnigScannerMatch(this._ptr, string.id, string.ptr, string.utf8Length, string.convertUtf16OffsetToUtf8(startPosition), options);
		if (resultPtr === 0) return null;
		const HEAPU32 = onigBinding2.HEAPU32;
		let offset = resultPtr / 4;
		const index = HEAPU32[offset++];
		const count = HEAPU32[offset++];
		const captureIndices = [];
		for (let i$1 = 0; i$1 < count; i$1++) {
			const beg = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
			const end = string.convertUtf8OffsetToUtf16(HEAPU32[offset++]);
			captureIndices[i$1] = {
				start: beg,
				end,
				length: end - beg
			};
		}
		return {
			index,
			captureIndices
		};
	}
};
function isInstantiatorOptionsObject(dataOrOptions) {
	return typeof dataOrOptions.instantiator === "function";
}
function isInstantiatorModule(dataOrOptions) {
	return typeof dataOrOptions.default === "function";
}
function isDataOptionsObject(dataOrOptions) {
	return typeof dataOrOptions.data !== "undefined";
}
function isResponse(dataOrOptions) {
	return typeof Response !== "undefined" && dataOrOptions instanceof Response;
}
function isArrayBuffer(data) {
	return typeof ArrayBuffer !== "undefined" && (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) || typeof Buffer !== "undefined" && Buffer.isBuffer?.(data) || typeof SharedArrayBuffer !== "undefined" && data instanceof SharedArrayBuffer || typeof Uint32Array !== "undefined" && data instanceof Uint32Array;
}
let initPromise;
function loadWasm(options) {
	if (initPromise) return initPromise;
	async function _load() {
		onigBinding = await main(async (info) => {
			let instance = options;
			instance = await instance;
			if (typeof instance === "function") instance = await instance(info);
			if (typeof instance === "function") instance = await instance(info);
			if (isInstantiatorOptionsObject(instance)) instance = await instance.instantiator(info);
			else if (isInstantiatorModule(instance)) instance = await instance.default(info);
			else {
				if (isDataOptionsObject(instance)) instance = instance.data;
				if (isResponse(instance)) if (typeof WebAssembly.instantiateStreaming === "function") instance = await _makeResponseStreamingLoader(instance)(info);
				else instance = await _makeResponseNonStreamingLoader(instance)(info);
				else if (isArrayBuffer(instance)) instance = await _makeArrayBufferLoader(instance)(info);
				else if (instance instanceof WebAssembly.Module) instance = await _makeArrayBufferLoader(instance)(info);
				else if ("default" in instance && instance.default instanceof WebAssembly.Module) instance = await _makeArrayBufferLoader(instance.default)(info);
			}
			if ("instance" in instance) instance = instance.instance;
			if ("exports" in instance) instance = instance.exports;
			return instance;
		});
	}
	initPromise = _load();
	return initPromise;
}
function _makeArrayBufferLoader(data) {
	return (importObject) => WebAssembly.instantiate(data, importObject);
}
function _makeResponseStreamingLoader(data) {
	return (importObject) => WebAssembly.instantiateStreaming(data, importObject);
}
function _makeResponseNonStreamingLoader(data) {
	return async (importObject) => {
		const arrayBuffer = await data.arrayBuffer();
		return WebAssembly.instantiate(arrayBuffer, importObject);
	};
}
async function createOnigurumaEngine(options) {
	if (options) await loadWasm(options);
	return {
		createScanner(patterns) {
			return new OnigScanner(patterns.map((p) => typeof p === "string" ? p : p.source));
		},
		createString(s$1) {
			return new OnigString(s$1);
		}
	};
}
const createHighlighter = /* @__PURE__ */ createdBundledHighlighter({
	langs: bundledLanguages,
	themes: bundledThemes,
	engine: () => createOnigurumaEngine(__vitePreload(() => import("./wasm-B-OLL6Uk.js"), [], import.meta.url))
});
const { codeToHtml, codeToHast, codeToTokens, codeToTokensBase, codeToTokensWithThemes, getSingletonHighlighter, getLastGrammarState } = /* @__PURE__ */ createSingletonShorthands(createHighlighter, { guessEmbeddedLanguages });
function r$2(e) {
	if ([...e].length !== 1) throw new Error(`Expected "${e}" to be a single code point`);
	return e.codePointAt(0);
}
function l$1(e, t, n) {
	return e.has(t) || e.set(t, n), e.get(t);
}
const i = new Set([
	"alnum",
	"alpha",
	"ascii",
	"blank",
	"cntrl",
	"digit",
	"graph",
	"lower",
	"print",
	"punct",
	"space",
	"upper",
	"word",
	"xdigit"
]), o$1 = String.raw;
function u(e, t) {
	if (e == null) throw new Error(t ?? "Value expected");
	return e;
}
const m$1 = o$1`\[\^?`, b$1 = `c.? | C(?:-.?)?|${o$1`[pP]\{(?:\^?[-\x20_]*[A-Za-z][-\x20\w]*\})?`}|${o$1`x[89A-Fa-f]\p{AHex}(?:\\x[89A-Fa-f]\p{AHex})*`}|${o$1`u(?:\p{AHex}{4})? | x\{[^\}]*\}? | x\p{AHex}{0,2}`}|${o$1`o\{[^\}]*\}?`}|${o$1`\d{1,3}`}`, y$1 = /[?*+][?+]?|\{(?:\d+(?:,\d*)?|,\d+)\}\??/, C$1 = new RegExp(o$1`
  \\ (?:
    ${b$1}
    | [gk]<[^>]*>?
    | [gk]'[^']*'?
    | .
  )
  | \( (?:
    \? (?:
      [:=!>({]
      | <[=!]
      | <[^>]*>
      | '[^']*'
      | ~\|?
      | #(?:[^)\\]|\\.?)*
      | [^:)]*[:)]
    )?
    | \*[^\)]*\)?
  )?
  | (?:${y$1.source})+
  | ${m$1}
  | .
`.replace(/\s+/g, ""), "gsu"), T$1 = new RegExp(o$1`
  \\ (?:
    ${b$1}
    | .
  )
  | \[:(?:\^?\p{Alpha}+|\^):\]
  | ${m$1}
  | &&
  | .
`.replace(/\s+/g, ""), "gsu");
function M(e, n = {}) {
	const t = {
		flags: "",
		...n,
		rules: {
			captureGroup: !1,
			singleline: !1,
			...n.rules
		}
	};
	if (typeof e != "string") throw new Error("String expected as pattern");
	const o$2 = Y(t.flags), s$1 = [o$2.extended], a$1 = {
		captureGroup: t.rules.captureGroup,
		getCurrentModX() {
			return s$1.at(-1);
		},
		numOpenGroups: 0,
		popModX() {
			s$1.pop();
		},
		pushModX(u$1) {
			s$1.push(u$1);
		},
		replaceCurrentModX(u$1) {
			s$1[s$1.length - 1] = u$1;
		},
		singleline: t.rules.singleline
	};
	let r$3 = [], i$1;
	for (C$1.lastIndex = 0; i$1 = C$1.exec(e);) {
		const u$1 = F$1(a$1, e, i$1[0], C$1.lastIndex);
		u$1.tokens ? r$3.push(...u$1.tokens) : u$1.token && r$3.push(u$1.token), u$1.lastIndex !== void 0 && (C$1.lastIndex = u$1.lastIndex);
	}
	const l$2 = [];
	let c = 0;
	r$3.filter((u$1) => u$1.type === "GroupOpen").forEach((u$1) => {
		u$1.kind === "capturing" ? u$1.number = ++c : u$1.raw === "(" && l$2.push(u$1);
	}), c || l$2.forEach((u$1, S$1) => {
		u$1.kind = "capturing", u$1.number = S$1 + 1;
	});
	const g = c || l$2.length;
	return {
		tokens: r$3.map((u$1) => u$1.type === "EscapedNumber" ? ee$1(u$1, g) : u$1).flat(),
		flags: o$2
	};
}
function F$1(e, n, t, o$2) {
	const [s$1, a$1] = t;
	if (t === "[" || t === "[^") {
		const r$3 = K$1(n, t, o$2);
		return {
			tokens: r$3.tokens,
			lastIndex: r$3.lastIndex
		};
	}
	if (s$1 === "\\") {
		if ("AbBGyYzZ".includes(a$1)) return { token: w$1(t, t) };
		if (/^\\g[<']/.test(t)) {
			if (!/^\\g(?:<[^>]+>|'[^']+')$/.test(t)) throw new Error(`Invalid group name "${t}"`);
			return { token: R$1(t) };
		}
		if (/^\\k[<']/.test(t)) {
			if (!/^\\k(?:<[^>]+>|'[^']+')$/.test(t)) throw new Error(`Invalid group name "${t}"`);
			return { token: A$1(t) };
		}
		if (a$1 === "K") return { token: I$1("keep", t) };
		if (a$1 === "N" || a$1 === "R") return { token: k$1("newline", t, { negate: a$1 === "N" }) };
		if (a$1 === "O") return { token: k$1("any", t) };
		if (a$1 === "X") return { token: k$1("text_segment", t) };
		const r$3 = x(t, { inCharClass: !1 });
		return Array.isArray(r$3) ? { tokens: r$3 } : { token: r$3 };
	}
	if (s$1 === "(") {
		if (a$1 === "*") return { token: j(t) };
		if (t === "(?{") throw new Error(`Unsupported callout "${t}"`);
		if (t.startsWith("(?#")) {
			if (n[o$2] !== ")") throw new Error("Unclosed comment group \"(?#\"");
			return { lastIndex: o$2 + 1 };
		}
		if (/^\(\?[-imx]+[:)]$/.test(t)) return { token: L$1(t, e) };
		if (e.pushModX(e.getCurrentModX()), e.numOpenGroups++, t === "(" && !e.captureGroup || t === "(?:") return { token: f$1("group", t) };
		if (t === "(?>") return { token: f$1("atomic", t) };
		if (t === "(?=" || t === "(?!" || t === "(?<=" || t === "(?<!") return { token: f$1(t[2] === "<" ? "lookbehind" : "lookahead", t, { negate: t.endsWith("!") }) };
		if (t === "(" && e.captureGroup || t.startsWith("(?<") && t.endsWith(">") || t.startsWith("(?'") && t.endsWith("'")) return { token: f$1("capturing", t, { ...t !== "(" && { name: t.slice(3, -1) } }) };
		if (t.startsWith("(?~")) {
			if (t === "(?~|") throw new Error(`Unsupported absence function kind "${t}"`);
			return { token: f$1("absence_repeater", t) };
		}
		throw t === "(?(" ? /* @__PURE__ */ new Error(`Unsupported conditional "${t}"`) : /* @__PURE__ */ new Error(`Invalid or unsupported group option "${t}"`);
	}
	if (t === ")") {
		if (e.popModX(), e.numOpenGroups--, e.numOpenGroups < 0) throw new Error("Unmatched \")\"");
		return { token: Q$1(t) };
	}
	if (e.getCurrentModX()) {
		if (t === "#") {
			const r$3 = n.indexOf(`
`, o$2);
			return { lastIndex: r$3 === -1 ? n.length : r$3 };
		}
		if (/^\s$/.test(t)) {
			const r$3 = /\s+/y;
			return r$3.lastIndex = o$2, { lastIndex: r$3.exec(n) ? r$3.lastIndex : o$2 };
		}
	}
	if (t === ".") return { token: k$1("dot", t) };
	if (t === "^" || t === "$") {
		const r$3 = e.singleline ? {
			"^": o$1`\A`,
			$: o$1`\Z`
		}[t] : t;
		return { token: w$1(r$3, t) };
	}
	return t === "|" ? { token: P$1(t) } : y$1.test(t) ? { tokens: te$1(t) } : { token: d(r$2(t), t) };
}
function K$1(e, n, t) {
	const o$2 = [E$1(n[1] === "^", n)];
	let s$1 = 1, a$1;
	for (T$1.lastIndex = t; a$1 = T$1.exec(e);) {
		const r$3 = a$1[0];
		if (r$3[0] === "[" && r$3[1] !== ":") s$1++, o$2.push(E$1(r$3[1] === "^", r$3));
		else if (r$3 === "]") {
			if (o$2.at(-1).type === "CharacterClassOpen") o$2.push(d(93, r$3));
			else if (s$1--, o$2.push(z$1(r$3)), !s$1) break;
		} else {
			const i$1 = X$1(r$3);
			Array.isArray(i$1) ? o$2.push(...i$1) : o$2.push(i$1);
		}
	}
	return {
		tokens: o$2,
		lastIndex: T$1.lastIndex || e.length
	};
}
function X$1(e) {
	if (e[0] === "\\") return x(e, { inCharClass: !0 });
	if (e[0] === "[") {
		const n = /\[:(?<negate>\^?)(?<name>[a-z]+):\]/.exec(e);
		if (!n || !i.has(n.groups.name)) throw new Error(`Invalid POSIX class "${e}"`);
		return k$1("posix", e, {
			value: n.groups.name,
			negate: !!n.groups.negate
		});
	}
	return e === "-" ? U$1(e) : e === "&&" ? H(e) : d(r$2(e), e);
}
function x(e, { inCharClass: n }) {
	const t = e[1];
	if (t === "c" || t === "C") return Z(e);
	if ("dDhHsSwW".includes(t)) return q(e);
	if (e.startsWith(o$1`\o{`)) throw new Error(`Incomplete, invalid, or unsupported octal code point "${e}"`);
	if (/^\\[pP]\{/.test(e)) {
		if (e.length === 3) throw new Error(`Incomplete or invalid Unicode property "${e}"`);
		return V$1(e);
	}
	if (/^\\x[89A-Fa-f]\p{AHex}/u.test(e)) try {
		const o$2 = e.split(/\\x/).slice(1).map((i$1) => parseInt(i$1, 16)), s$1 = new TextDecoder("utf-8", {
			ignoreBOM: !0,
			fatal: !0
		}).decode(new Uint8Array(o$2)), a$1 = new TextEncoder();
		return [...s$1].map((i$1) => {
			const l$2 = [...a$1.encode(i$1)].map((c) => `\\x${c.toString(16)}`).join("");
			return d(r$2(i$1), l$2);
		});
	} catch {
		throw new Error(`Multibyte code "${e}" incomplete or invalid in Oniguruma`);
	}
	if (t === "u" || t === "x") return d(J$1(e), e);
	if ($$1.has(t)) return d($$1.get(t), e);
	if (/\d/.test(t)) return W$1(n, e);
	if (e === "\\") throw new Error(o$1`Incomplete escape "\"`);
	if (t === "M") throw new Error(`Unsupported meta "${e}"`);
	if ([...e].length === 2) return d(e.codePointAt(1), e);
	throw new Error(`Unexpected escape "${e}"`);
}
function P$1(e) {
	return {
		type: "Alternator",
		raw: e
	};
}
function w$1(e, n) {
	return {
		type: "Assertion",
		kind: e,
		raw: n
	};
}
function A$1(e) {
	return {
		type: "Backreference",
		raw: e
	};
}
function d(e, n) {
	return {
		type: "Character",
		value: e,
		raw: n
	};
}
function z$1(e) {
	return {
		type: "CharacterClassClose",
		raw: e
	};
}
function U$1(e) {
	return {
		type: "CharacterClassHyphen",
		raw: e
	};
}
function H(e) {
	return {
		type: "CharacterClassIntersector",
		raw: e
	};
}
function E$1(e, n) {
	return {
		type: "CharacterClassOpen",
		negate: e,
		raw: n
	};
}
function k$1(e, n, t = {}) {
	return {
		type: "CharacterSet",
		kind: e,
		...t,
		raw: n
	};
}
function I$1(e, n, t = {}) {
	return e === "keep" ? {
		type: "Directive",
		kind: e,
		raw: n
	} : {
		type: "Directive",
		kind: e,
		flags: u(t.flags),
		raw: n
	};
}
function W$1(e, n) {
	return {
		type: "EscapedNumber",
		inCharClass: e,
		raw: n
	};
}
function Q$1(e) {
	return {
		type: "GroupClose",
		raw: e
	};
}
function f$1(e, n, t = {}) {
	return {
		type: "GroupOpen",
		kind: e,
		...t,
		raw: n
	};
}
function D$1(e, n, t, o$2) {
	return {
		type: "NamedCallout",
		kind: e,
		tag: n,
		arguments: t,
		raw: o$2
	};
}
function _$1(e, n, t, o$2) {
	return {
		type: "Quantifier",
		kind: e,
		min: n,
		max: t,
		raw: o$2
	};
}
function R$1(e) {
	return {
		type: "Subroutine",
		raw: e
	};
}
const B$1 = new Set([
	"COUNT",
	"CMP",
	"ERROR",
	"FAIL",
	"MAX",
	"MISMATCH",
	"SKIP",
	"TOTAL_COUNT"
]), $$1 = new Map([
	["a", 7],
	["b", 8],
	["e", 27],
	["f", 12],
	["n", 10],
	["r", 13],
	["t", 9],
	["v", 11]
]);
function Z(e) {
	const n = e[1] === "c" ? e[2] : e[3];
	if (!n || !/[A-Za-z]/.test(n)) throw new Error(`Unsupported control character "${e}"`);
	return d(r$2(n.toUpperCase()) - 64, e);
}
function L$1(e, n) {
	let { on: t, off: o$2 } = /^\(\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(e).groups;
	o$2 ??= "";
	const s$1 = (n.getCurrentModX() || t.includes("x")) && !o$2.includes("x"), a$1 = v(t), r$3 = v(o$2), i$1 = {};
	if (a$1 && (i$1.enable = a$1), r$3 && (i$1.disable = r$3), e.endsWith(")")) return n.replaceCurrentModX(s$1), I$1("flags", e, { flags: i$1 });
	if (e.endsWith(":")) return n.pushModX(s$1), n.numOpenGroups++, f$1("group", e, { ...(a$1 || r$3) && { flags: i$1 } });
	throw new Error(`Unexpected flag modifier "${e}"`);
}
function j(e) {
	const n = /\(\*(?<name>[A-Za-z_]\w*)?(?:\[(?<tag>(?:[A-Za-z_]\w*)?)\])?(?:\{(?<args>[^}]*)\})?\)/.exec(e);
	if (!n) throw new Error(`Incomplete or invalid named callout "${e}"`);
	const { name: t, tag: o$2, args: s$1 } = n.groups;
	if (!t) throw new Error(`Invalid named callout "${e}"`);
	if (o$2 === "") throw new Error(`Named callout tag with empty value not allowed "${e}"`);
	const a$1 = s$1 ? s$1.split(",").filter((g) => g !== "").map((g) => /^[+-]?\d+$/.test(g) ? +g : g) : [], [r$3, i$1, l$2] = a$1, c = B$1.has(t) ? t.toLowerCase() : "custom";
	switch (c) {
		case "fail":
		case "mismatch":
		case "skip":
			if (a$1.length > 0) throw new Error(`Named callout arguments not allowed "${a$1}"`);
			break;
		case "error":
			if (a$1.length > 1) throw new Error(`Named callout allows only one argument "${a$1}"`);
			if (typeof r$3 == "string") throw new Error(`Named callout argument must be a number "${r$3}"`);
			break;
		case "max":
			if (!a$1.length || a$1.length > 2) throw new Error(`Named callout must have one or two arguments "${a$1}"`);
			if (typeof r$3 == "string" && !/^[A-Za-z_]\w*$/.test(r$3)) throw new Error(`Named callout argument one must be a tag or number "${r$3}"`);
			if (a$1.length === 2 && (typeof i$1 == "number" || !/^[<>X]$/.test(i$1))) throw new Error(`Named callout optional argument two must be '<', '>', or 'X' "${i$1}"`);
			break;
		case "count":
		case "total_count":
			if (a$1.length > 1) throw new Error(`Named callout allows only one argument "${a$1}"`);
			if (a$1.length === 1 && (typeof r$3 == "number" || !/^[<>X]$/.test(r$3))) throw new Error(`Named callout optional argument must be '<', '>', or 'X' "${r$3}"`);
			break;
		case "cmp":
			if (a$1.length !== 3) throw new Error(`Named callout must have three arguments "${a$1}"`);
			if (typeof r$3 == "string" && !/^[A-Za-z_]\w*$/.test(r$3)) throw new Error(`Named callout argument one must be a tag or number "${r$3}"`);
			if (typeof i$1 == "number" || !/^(?:[<>!=]=|[<>])$/.test(i$1)) throw new Error(`Named callout argument two must be '==', '!=', '>', '<', '>=', or '<=' "${i$1}"`);
			if (typeof l$2 == "string" && !/^[A-Za-z_]\w*$/.test(l$2)) throw new Error(`Named callout argument three must be a tag or number "${l$2}"`);
			break;
		case "custom": throw new Error(`Undefined callout name "${t}"`);
		default: throw new Error(`Unexpected named callout kind "${c}"`);
	}
	return D$1(c, o$2 ?? null, s$1?.split(",") ?? null, e);
}
function O$1(e) {
	let n = null, t, o$2;
	if (e[0] === "{") {
		const { minStr: s$1, maxStr: a$1 } = /^\{(?<minStr>\d*)(?:,(?<maxStr>\d*))?/.exec(e).groups, r$3 = 1e5;
		if (+s$1 > r$3 || a$1 && +a$1 > r$3) throw new Error("Quantifier value unsupported in Oniguruma");
		if (t = +s$1, o$2 = a$1 === void 0 ? +s$1 : a$1 === "" ? Infinity : +a$1, t > o$2 && (n = "possessive", [t, o$2] = [o$2, t]), e.endsWith("?")) {
			if (n === "possessive") throw new Error("Unsupported possessive interval quantifier chain with \"?\"");
			n = "lazy";
		} else n || (n = "greedy");
	} else t = e[0] === "+" ? 1 : 0, o$2 = e[0] === "?" ? 1 : Infinity, n = e[1] === "+" ? "possessive" : e[1] === "?" ? "lazy" : "greedy";
	return _$1(n, t, o$2, e);
}
function q(e) {
	const n = e[1].toLowerCase();
	return k$1({
		d: "digit",
		h: "hex",
		s: "space",
		w: "word"
	}[n], e, { negate: e[1] !== n });
}
function V$1(e) {
	const { p: n, neg: t, value: o$2 } = /^\\(?<p>[pP])\{(?<neg>\^?)(?<value>[^}]+)/.exec(e).groups;
	return k$1("property", e, {
		value: o$2,
		negate: n === "P" && !t || n === "p" && !!t
	});
}
function v(e) {
	const n = {};
	return e.includes("i") && (n.ignoreCase = !0), e.includes("m") && (n.dotAll = !0), e.includes("x") && (n.extended = !0), Object.keys(n).length ? n : null;
}
function Y(e) {
	const n = {
		ignoreCase: !1,
		dotAll: !1,
		extended: !1,
		digitIsAscii: !1,
		posixIsAscii: !1,
		spaceIsAscii: !1,
		wordIsAscii: !1,
		textSegmentMode: null
	};
	for (let t = 0; t < e.length; t++) {
		const o$2 = e[t];
		if (!"imxDPSWy".includes(o$2)) throw new Error(`Invalid flag "${o$2}"`);
		if (o$2 === "y") {
			if (!/^y{[gw]}/.test(e.slice(t))) throw new Error("Invalid or unspecified flag \"y\" mode");
			n.textSegmentMode = e[t + 2] === "g" ? "grapheme" : "word", t += 3;
			continue;
		}
		n[{
			i: "ignoreCase",
			m: "dotAll",
			x: "extended",
			D: "digitIsAscii",
			P: "posixIsAscii",
			S: "spaceIsAscii",
			W: "wordIsAscii"
		}[o$2]] = !0;
	}
	return n;
}
function J$1(e) {
	if (/^(?:\\u(?!\p{AHex}{4})|\\x(?!\p{AHex}{1,2}|\{\p{AHex}{1,8}\}))/u.test(e)) throw new Error(`Incomplete or invalid escape "${e}"`);
	const n = e[2] === "{" ? /^\\x\{\s*(?<hex>\p{AHex}+)/u.exec(e).groups.hex : e.slice(2);
	return parseInt(n, 16);
}
function ee$1(e, n) {
	const { raw: t, inCharClass: o$2 } = e, s$1 = t.slice(1);
	if (!o$2 && (s$1 !== "0" && s$1.length === 1 || s$1[0] !== "0" && +s$1 <= n)) return [A$1(t)];
	const a$1 = [], r$3 = s$1.match(/^[0-7]+|\d/g);
	for (let i$1 = 0; i$1 < r$3.length; i$1++) {
		const l$2 = r$3[i$1];
		let c;
		if (i$1 === 0 && l$2 !== "8" && l$2 !== "9") {
			if (c = parseInt(l$2, 8), c > 127) throw new Error(o$1`Octal encoded byte above 177 unsupported "${t}"`);
		} else c = r$2(l$2);
		a$1.push(d(c, (i$1 === 0 ? "\\" : "") + l$2));
	}
	return a$1;
}
function te$1(e) {
	const n = [], t = new RegExp(y$1, "gy");
	let o$2;
	for (; o$2 = t.exec(e);) {
		const s$1 = o$2[0];
		if (s$1[0] === "{") {
			const a$1 = /^\{(?<min>\d+),(?<max>\d+)\}\??$/.exec(s$1);
			if (a$1) {
				const { min: r$3, max: i$1 } = a$1.groups;
				if (+r$3 > +i$1 && s$1.endsWith("?")) {
					t.lastIndex--, n.push(O$1(s$1.slice(0, -1)));
					continue;
				}
			}
		}
		n.push(O$1(s$1));
	}
	return n;
}
function o(e, t) {
	if (!Array.isArray(e.body)) throw new Error("Expected node with body array");
	if (e.body.length !== 1) return !1;
	const r$3 = e.body[0];
	return !t || Object.keys(t).every((n) => t[n] === r$3[n]);
}
function s(e) {
	return y.has(e.type);
}
const y = new Set([
	"AbsenceFunction",
	"Backreference",
	"CapturingGroup",
	"Character",
	"CharacterClass",
	"CharacterSet",
	"Group",
	"Quantifier",
	"Subroutine"
]);
function J(e, r$3 = {}) {
	const n = {
		flags: "",
		normalizeUnknownPropertyNames: !1,
		skipBackrefValidation: !1,
		skipLookbehindValidation: !1,
		skipPropertyNameValidation: !1,
		unicodePropertyMap: null,
		...r$3,
		rules: {
			captureGroup: !1,
			singleline: !1,
			...r$3.rules
		}
	}, t = M(e, {
		flags: n.flags,
		rules: {
			captureGroup: n.rules.captureGroup,
			singleline: n.rules.singleline
		}
	}), s$1 = (p, N) => {
		const u$1 = t.tokens[o$2.nextIndex];
		switch (o$2.parent = p, o$2.nextIndex++, u$1.type) {
			case "Alternator": return b();
			case "Assertion": return W(u$1);
			case "Backreference": return X(u$1, o$2);
			case "Character": return m(u$1.value, { useLastValid: !!N.isCheckingRangeEnd });
			case "CharacterClassHyphen": return ee(u$1, o$2, N);
			case "CharacterClassOpen": return re(u$1, o$2, N);
			case "CharacterSet": return ne(u$1, o$2);
			case "Directive": return I(u$1.kind, { flags: u$1.flags });
			case "GroupOpen": return te(u$1, o$2, N);
			case "NamedCallout": return U(u$1.kind, u$1.tag, u$1.arguments);
			case "Quantifier": return oe(u$1, o$2);
			case "Subroutine": return ae(u$1, o$2);
			default: throw new Error(`Unexpected token type "${u$1.type}"`);
		}
	}, o$2 = {
		capturingGroups: [],
		hasNumberedRef: !1,
		namedGroupsByName: /* @__PURE__ */ new Map(),
		nextIndex: 0,
		normalizeUnknownPropertyNames: n.normalizeUnknownPropertyNames,
		parent: null,
		skipBackrefValidation: n.skipBackrefValidation,
		skipLookbehindValidation: n.skipLookbehindValidation,
		skipPropertyNameValidation: n.skipPropertyNameValidation,
		subroutines: [],
		tokens: t.tokens,
		unicodePropertyMap: n.unicodePropertyMap,
		walk: s$1
	}, i$1 = B(T(t.flags));
	let d$1 = i$1.body[0];
	for (; o$2.nextIndex < t.tokens.length;) {
		const p = s$1(d$1, {});
		p.type === "Alternative" ? (i$1.body.push(p), d$1 = p) : d$1.body.push(p);
	}
	const { capturingGroups: a$1, hasNumberedRef: l$2, namedGroupsByName: c, subroutines: f$2 } = o$2;
	if (l$2 && c.size && !n.rules.captureGroup) throw new Error("Numbered backref/subroutine not allowed when using named capture");
	for (const { ref: p } of f$2) if (typeof p == "number") {
		if (p > a$1.length) throw new Error("Subroutine uses a group number that's not defined");
		p && (a$1[p - 1].isSubroutined = !0);
	} else if (c.has(p)) {
		if (c.get(p).length > 1) throw new Error(o$1`Subroutine uses a duplicate group name "\g<${p}>"`);
		c.get(p)[0].isSubroutined = !0;
	} else throw new Error(o$1`Subroutine uses a group name that's not defined "\g<${p}>"`);
	return i$1;
}
function W({ kind: e }) {
	return F(u({
		"^": "line_start",
		$: "line_end",
		"\\A": "string_start",
		"\\b": "word_boundary",
		"\\B": "word_boundary",
		"\\G": "search_start",
		"\\y": "text_segment_boundary",
		"\\Y": "text_segment_boundary",
		"\\z": "string_end",
		"\\Z": "string_end_newline"
	}[e], `Unexpected assertion kind "${e}"`), { negate: e === o$1`\B` || e === o$1`\Y` });
}
function X({ raw: e }, r$3) {
	const n = /^\\k[<']/.test(e), t = n ? e.slice(3, -1) : e.slice(1), s$1 = (o$2, i$1 = !1) => {
		const d$1 = r$3.capturingGroups.length;
		let a$1 = !1;
		if (o$2 > d$1) if (r$3.skipBackrefValidation) a$1 = !0;
		else throw new Error(`Not enough capturing groups defined to the left "${e}"`);
		return r$3.hasNumberedRef = !0, k(i$1 ? d$1 + 1 - o$2 : o$2, { orphan: a$1 });
	};
	if (n) {
		const o$2 = /^(?<sign>-?)0*(?<num>[1-9]\d*)$/.exec(t);
		if (o$2) return s$1(+o$2.groups.num, !!o$2.groups.sign);
		if (/[-+]/.test(t)) throw new Error(`Invalid backref name "${e}"`);
		if (!r$3.namedGroupsByName.has(t)) throw new Error(`Group name not defined to the left "${e}"`);
		return k(t);
	}
	return s$1(+t);
}
function ee(e, r$3, n) {
	const { tokens: t, walk: s$1 } = r$3, o$2 = r$3.parent, i$1 = o$2.body.at(-1), d$1 = t[r$3.nextIndex];
	if (!n.isCheckingRangeEnd && i$1 && i$1.type !== "CharacterClass" && i$1.type !== "CharacterClassRange" && d$1 && d$1.type !== "CharacterClassOpen" && d$1.type !== "CharacterClassClose" && d$1.type !== "CharacterClassIntersector") {
		const a$1 = s$1(o$2, {
			...n,
			isCheckingRangeEnd: !0
		});
		if (i$1.type === "Character" && a$1.type === "Character") return o$2.body.pop(), L(i$1, a$1);
		throw new Error("Invalid character class range");
	}
	return m(r$2("-"));
}
function re({ negate: e }, r$3, n) {
	const { tokens: t, walk: s$1 } = r$3, o$2 = t[r$3.nextIndex], i$1 = [C()];
	let d$1 = z(o$2);
	for (; d$1.type !== "CharacterClassClose";) {
		if (d$1.type === "CharacterClassIntersector") i$1.push(C()), r$3.nextIndex++;
		else {
			const l$2 = i$1.at(-1);
			l$2.body.push(s$1(l$2, n));
		}
		d$1 = z(t[r$3.nextIndex], o$2);
	}
	const a$1 = C({ negate: e });
	return i$1.length === 1 ? a$1.body = i$1[0].body : (a$1.kind = "intersection", a$1.body = i$1.map((l$2) => l$2.body.length === 1 ? l$2.body[0] : l$2)), r$3.nextIndex++, a$1;
}
function ne({ kind: e, negate: r$3, value: n }, t) {
	const { normalizeUnknownPropertyNames: s$1, skipPropertyNameValidation: o$2, unicodePropertyMap: i$1 } = t;
	if (e === "property") {
		const d$1 = w(n);
		if (i.has(d$1) && !i$1?.has(d$1)) e = "posix", n = d$1;
		else return Q(n, {
			negate: r$3,
			normalizeUnknownPropertyNames: s$1,
			skipPropertyNameValidation: o$2,
			unicodePropertyMap: i$1
		});
	}
	return e === "posix" ? R(n, { negate: r$3 }) : E(e, { negate: r$3 });
}
function te(e, r$3, n) {
	const { tokens: t, capturingGroups: s$1, namedGroupsByName: o$2, skipLookbehindValidation: i$1, walk: d$1 } = r$3, a$1 = ie(e), l$2 = a$1.type === "AbsenceFunction", c = $(a$1), f$2 = c && a$1.negate;
	if (a$1.type === "CapturingGroup" && (s$1.push(a$1), a$1.name && l$1(o$2, a$1.name, []).push(a$1)), l$2 && n.isInAbsenceFunction) throw new Error("Nested absence function not supported by Oniguruma");
	let p = D(t[r$3.nextIndex]);
	for (; p.type !== "GroupClose";) {
		if (p.type === "Alternator") a$1.body.push(b()), r$3.nextIndex++;
		else {
			const N = a$1.body.at(-1), u$1 = d$1(N, {
				...n,
				isInAbsenceFunction: n.isInAbsenceFunction || l$2,
				isInLookbehind: n.isInLookbehind || c,
				isInNegLookbehind: n.isInNegLookbehind || f$2
			});
			if (N.body.push(u$1), (c || n.isInLookbehind) && !i$1) {
				const v$1 = "Lookbehind includes a pattern not allowed by Oniguruma";
				if (f$2 || n.isInNegLookbehind) {
					if (M$1(u$1) || u$1.type === "CapturingGroup") throw new Error(v$1);
				} else if (M$1(u$1) || $(u$1) && u$1.negate) throw new Error(v$1);
			}
		}
		p = D(t[r$3.nextIndex]);
	}
	return r$3.nextIndex++, a$1;
}
function oe({ kind: e, min: r$3, max: n }, t) {
	const s$1 = t.parent, o$2 = s$1.body.at(-1);
	if (!o$2 || !s(o$2)) throw new Error("Quantifier requires a repeatable token");
	const i$1 = _(e, r$3, n, o$2);
	return s$1.body.pop(), i$1;
}
function ae({ raw: e }, r$3) {
	const { capturingGroups: n, subroutines: t } = r$3;
	let s$1 = e.slice(3, -1);
	const o$2 = /^(?<sign>[-+]?)0*(?<num>[1-9]\d*)$/.exec(s$1);
	if (o$2) {
		const d$1 = +o$2.groups.num, a$1 = n.length;
		if (r$3.hasNumberedRef = !0, s$1 = {
			"": d$1,
			"+": a$1 + d$1,
			"-": a$1 + 1 - d$1
		}[o$2.groups.sign], s$1 < 1) throw new Error("Invalid subroutine number");
	} else s$1 === "0" && (s$1 = 0);
	const i$1 = O(s$1);
	return t.push(i$1), i$1;
}
function G(e, r$3) {
	if (e !== "repeater") throw new Error(`Unexpected absence function kind "${e}"`);
	return {
		type: "AbsenceFunction",
		kind: e,
		body: h(r$3?.body)
	};
}
function b(e) {
	return {
		type: "Alternative",
		body: V(e?.body)
	};
}
function F(e, r$3) {
	const n = {
		type: "Assertion",
		kind: e
	};
	return (e === "word_boundary" || e === "text_segment_boundary") && (n.negate = !!r$3?.negate), n;
}
function k(e, r$3) {
	const n = !!r$3?.orphan;
	return {
		type: "Backreference",
		ref: e,
		...n && { orphan: n }
	};
}
function P(e, r$3) {
	const n = {
		name: void 0,
		isSubroutined: !1,
		...r$3
	};
	if (n.name !== void 0 && !se(n.name)) throw new Error(`Group name "${n.name}" invalid in Oniguruma`);
	return {
		type: "CapturingGroup",
		number: e,
		...n.name && { name: n.name },
		...n.isSubroutined && { isSubroutined: n.isSubroutined },
		body: h(r$3?.body)
	};
}
function m(e, r$3) {
	const n = {
		useLastValid: !1,
		...r$3
	};
	if (e > 1114111) {
		const t = e.toString(16);
		if (n.useLastValid) e = 1114111;
		else throw e > 1310719 ? /* @__PURE__ */ new Error(`Invalid code point out of range "\\x{${t}}"`) : /* @__PURE__ */ new Error(`Invalid code point out of range in JS "\\x{${t}}"`);
	}
	return {
		type: "Character",
		value: e
	};
}
function C(e) {
	const r$3 = {
		kind: "union",
		negate: !1,
		...e
	};
	return {
		type: "CharacterClass",
		kind: r$3.kind,
		negate: r$3.negate,
		body: V(e?.body)
	};
}
function L(e, r$3) {
	if (r$3.value < e.value) throw new Error("Character class range out of order");
	return {
		type: "CharacterClassRange",
		min: e,
		max: r$3
	};
}
function E(e, r$3) {
	const n = !!r$3?.negate, t = {
		type: "CharacterSet",
		kind: e
	};
	return (e === "digit" || e === "hex" || e === "newline" || e === "space" || e === "word") && (t.negate = n), (e === "text_segment" || e === "newline" && !n) && (t.variableLength = !0), t;
}
function I(e, r$3 = {}) {
	if (e === "keep") return {
		type: "Directive",
		kind: e
	};
	if (e === "flags") return {
		type: "Directive",
		kind: e,
		flags: u(r$3.flags)
	};
	throw new Error(`Unexpected directive kind "${e}"`);
}
function T(e) {
	return {
		type: "Flags",
		...e
	};
}
function A(e) {
	const r$3 = e?.atomic, n = e?.flags;
	if (r$3 && n) throw new Error("Atomic group cannot have flags");
	return {
		type: "Group",
		...r$3 && { atomic: r$3 },
		...n && { flags: n },
		body: h(e?.body)
	};
}
function K(e) {
	const r$3 = {
		behind: !1,
		negate: !1,
		...e
	};
	return {
		type: "LookaroundAssertion",
		kind: r$3.behind ? "lookbehind" : "lookahead",
		negate: r$3.negate,
		body: h(e?.body)
	};
}
function U(e, r$3, n) {
	return {
		type: "NamedCallout",
		kind: e,
		tag: r$3,
		arguments: n
	};
}
function R(e, r$3) {
	const n = !!r$3?.negate;
	if (!i.has(e)) throw new Error(`Invalid POSIX class "${e}"`);
	return {
		type: "CharacterSet",
		kind: "posix",
		value: e,
		negate: n
	};
}
function _(e, r$3, n, t) {
	if (r$3 > n) throw new Error("Invalid reversed quantifier range");
	return {
		type: "Quantifier",
		kind: e,
		min: r$3,
		max: n,
		body: t
	};
}
function B(e, r$3) {
	return {
		type: "Regex",
		body: h(r$3?.body),
		flags: e
	};
}
function O(e) {
	return {
		type: "Subroutine",
		ref: e
	};
}
function Q(e, r$3) {
	const n = {
		negate: !1,
		normalizeUnknownPropertyNames: !1,
		skipPropertyNameValidation: !1,
		unicodePropertyMap: null,
		...r$3
	};
	let t = n.unicodePropertyMap?.get(w(e));
	if (!t) {
		if (n.normalizeUnknownPropertyNames) t = de(e);
		else if (n.unicodePropertyMap && !n.skipPropertyNameValidation) throw new Error(o$1`Invalid Unicode property "\p{${e}}"`);
	}
	return {
		type: "CharacterSet",
		kind: "property",
		value: t ?? e,
		negate: n.negate
	};
}
function ie({ flags: e, kind: r$3, name: n, negate: t, number: s$1 }) {
	switch (r$3) {
		case "absence_repeater": return G("repeater");
		case "atomic": return A({ atomic: !0 });
		case "capturing": return P(s$1, { name: n });
		case "group": return A({ flags: e });
		case "lookahead":
		case "lookbehind": return K({
			behind: r$3 === "lookbehind",
			negate: t
		});
		default: throw new Error(`Unexpected group kind "${r$3}"`);
	}
}
function h(e) {
	if (e === void 0) e = [b()];
	else if (!Array.isArray(e) || !e.length || !e.every((r$3) => r$3.type === "Alternative")) throw new Error("Invalid body; expected array of one or more Alternative nodes");
	return e;
}
function V(e) {
	if (e === void 0) e = [];
	else if (!Array.isArray(e) || !e.every((r$3) => !!r$3.type)) throw new Error("Invalid body; expected array of nodes");
	return e;
}
function M$1(e) {
	return e.type === "LookaroundAssertion" && e.kind === "lookahead";
}
function $(e) {
	return e.type === "LookaroundAssertion" && e.kind === "lookbehind";
}
function se(e) {
	return /^[\p{Alpha}\p{Pc}][^)]*$/u.test(e);
}
function de(e) {
	return e.trim().replace(/[- _]+/g, "_").replace(/[A-Z][a-z]+(?=[A-Z])/g, "$&_").replace(/[A-Za-z]+/g, (r$3) => r$3[0].toUpperCase() + r$3.slice(1).toLowerCase());
}
function w(e) {
	return e.replace(/[- _]+/g, "").toLowerCase();
}
function z(e, r$3) {
	return u(e, `${r$3?.type === "Character" && r$3.value === 93 ? "Empty" : "Unclosed"} character class`);
}
function D(e) {
	return u(e, "Unclosed group");
}
function S(a$1, v$1, N = null) {
	function u$1(e, s$1) {
		for (let t = 0; t < e.length; t++) {
			const r$3 = n(e[t], s$1, t, e);
			t = Math.max(-1, t + r$3);
		}
	}
	function n(e, s$1 = null, t = null, r$3 = null) {
		let i$1 = 0, c = !1;
		const d$1 = {
			node: e,
			parent: s$1,
			key: t,
			container: r$3,
			root: a$1,
			remove() {
				f(r$3).splice(Math.max(0, l(t) + i$1), 1), i$1--, c = !0;
			},
			removeAllNextSiblings() {
				return f(r$3).splice(l(t) + 1);
			},
			removeAllPrevSiblings() {
				const o$2 = l(t) + i$1;
				return i$1 -= o$2, f(r$3).splice(0, Math.max(0, o$2));
			},
			replaceWith(o$2, y$2 = {}) {
				const b$2 = !!y$2.traverse;
				r$3 ? r$3[Math.max(0, l(t) + i$1)] = o$2 : u(s$1, "Can't replace root node")[t] = o$2, b$2 && n(o$2, s$1, t, r$3), c = !0;
			},
			replaceWithMultiple(o$2, y$2 = {}) {
				const b$2 = !!y$2.traverse;
				if (f(r$3).splice(Math.max(0, l(t) + i$1), 1, ...o$2), i$1 += o$2.length - 1, b$2) {
					let g = 0;
					for (let x$1 = 0; x$1 < o$2.length; x$1++) g += n(o$2[x$1], s$1, l(t) + x$1 + g, r$3);
				}
				c = !0;
			},
			skip() {
				c = !0;
			}
		}, { type: m$2 } = e, h$1 = v$1["*"], p = v$1[m$2], R$2 = typeof h$1 == "function" ? h$1 : h$1?.enter, P$2 = typeof p == "function" ? p : p?.enter;
		if (R$2?.(d$1, N), P$2?.(d$1, N), !c) switch (m$2) {
			case "AbsenceFunction":
			case "CapturingGroup":
			case "Group":
				u$1(e.body, e);
				break;
			case "Alternative":
			case "CharacterClass":
				u$1(e.body, e);
				break;
			case "Assertion":
			case "Backreference":
			case "Character":
			case "CharacterSet":
			case "Directive":
			case "Flags":
			case "NamedCallout":
			case "Subroutine": break;
			case "CharacterClassRange":
				n(e.min, e, "min"), n(e.max, e, "max");
				break;
			case "LookaroundAssertion":
				u$1(e.body, e);
				break;
			case "Quantifier":
				n(e.body, e, "body");
				break;
			case "Regex":
				u$1(e.body, e), n(e.flags, e, "flags");
				break;
			default: throw new Error(`Unexpected node type "${m$2}"`);
		}
		return p?.exit?.(d$1, N), h$1?.exit?.(d$1, N), i$1;
	}
	return n(a$1), a$1;
}
function f(a$1) {
	if (!Array.isArray(a$1)) throw new Error("Container expected");
	return a$1;
}
function l(a$1) {
	if (typeof a$1 != "number") throw new Error("Numeric key expected");
	return a$1;
}
const noncapturingDelim = String.raw`\(\?(?:[:=!>A-Za-z\-]|<[=!]|\(DEFINE\))`;
function incrementIfAtLeast$1(arr, threshold) {
	for (let i$1 = 0; i$1 < arr.length; i$1++) if (arr[i$1] >= threshold) arr[i$1]++;
}
function spliceStr(str, pos, oldValue, newValue) {
	return str.slice(0, pos) + newValue + str.slice(pos + oldValue.length);
}
const Context = Object.freeze({
	DEFAULT: "DEFAULT",
	CHAR_CLASS: "CHAR_CLASS"
});
function replaceUnescaped(expression, needle, replacement, context) {
	const re$1 = new RegExp(String.raw`${needle}|(?<$skip>\[\^?|\\?.)`, "gsu");
	const negated = [false];
	let numCharClassesOpen = 0;
	let result = "";
	for (const match of expression.matchAll(re$1)) {
		const { 0: m$2, groups: { $skip } } = match;
		if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) {
			if (replacement instanceof Function) result += replacement(match, {
				context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,
				negated: negated[negated.length - 1]
			});
			else result += replacement;
			continue;
		}
		if (m$2[0] === "[") {
			numCharClassesOpen++;
			negated.push(m$2[1] === "^");
		} else if (m$2 === "]" && numCharClassesOpen) {
			numCharClassesOpen--;
			negated.pop();
		}
		result += m$2;
	}
	return result;
}
function forEachUnescaped(expression, needle, callback, context) {
	replaceUnescaped(expression, needle, callback, context);
}
function execUnescaped(expression, needle, pos = 0, context) {
	if (!new RegExp(needle, "su").test(expression)) return null;
	const re$1 = new RegExp(`${needle}|(?<$skip>\\\\?.)`, "gsu");
	re$1.lastIndex = pos;
	let numCharClassesOpen = 0;
	let match;
	while (match = re$1.exec(expression)) {
		const { 0: m$2, groups: { $skip } } = match;
		if (!$skip && (!context || context === Context.DEFAULT === !numCharClassesOpen)) return match;
		if (m$2 === "[") numCharClassesOpen++;
		else if (m$2 === "]" && numCharClassesOpen) numCharClassesOpen--;
		if (re$1.lastIndex == match.index) re$1.lastIndex++;
	}
	return null;
}
function hasUnescaped(expression, needle, context) {
	return !!execUnescaped(expression, needle, 0, context);
}
function getGroupContents(expression, contentsStartPos) {
	const token$1 = /\\?./gsu;
	token$1.lastIndex = contentsStartPos;
	let contentsEndPos = expression.length;
	let numCharClassesOpen = 0;
	let numGroupsOpen = 1;
	let match;
	while (match = token$1.exec(expression)) {
		const [m$2] = match;
		if (m$2 === "[") numCharClassesOpen++;
		else if (!numCharClassesOpen) {
			if (m$2 === "(") numGroupsOpen++;
			else if (m$2 === ")") {
				numGroupsOpen--;
				if (!numGroupsOpen) {
					contentsEndPos = match.index;
					break;
				}
			}
		} else if (m$2 === "]") numCharClassesOpen--;
	}
	return expression.slice(contentsStartPos, contentsEndPos);
}
const atomicPluginToken = new RegExp(String.raw`(?<noncapturingStart>${noncapturingDelim})|(?<capturingStart>\((?:\?<[^>]+>)?)|\\?.`, "gsu");
function atomic(expression, data) {
	const hiddenCaptures = data?.hiddenCaptures ?? [];
	let captureTransfers = data?.captureTransfers ?? /* @__PURE__ */ new Map();
	if (!/\(\?>/.test(expression)) return {
		pattern: expression,
		captureTransfers,
		hiddenCaptures
	};
	const aGDelim = "(?>";
	const emulatedAGDelim = "(?:(?=(";
	const captureNumMap = [0];
	const addedHiddenCaptures = [];
	let numCapturesBeforeAG = 0;
	let numAGs = 0;
	let aGPos = NaN;
	let hasProcessedAG;
	do {
		hasProcessedAG = false;
		let numCharClassesOpen = 0;
		let numGroupsOpenInAG = 0;
		let inAG = false;
		let match;
		atomicPluginToken.lastIndex = Number.isNaN(aGPos) ? 0 : aGPos + 7;
		while (match = atomicPluginToken.exec(expression)) {
			const { 0: m$2, index, groups: { capturingStart, noncapturingStart } } = match;
			if (m$2 === "[") numCharClassesOpen++;
			else if (!numCharClassesOpen) {
				if (m$2 === aGDelim && !inAG) {
					aGPos = index;
					inAG = true;
				} else if (inAG && noncapturingStart) numGroupsOpenInAG++;
				else if (capturingStart) if (inAG) numGroupsOpenInAG++;
				else {
					numCapturesBeforeAG++;
					captureNumMap.push(numCapturesBeforeAG + numAGs);
				}
				else if (m$2 === ")" && inAG) {
					if (!numGroupsOpenInAG) {
						numAGs++;
						const addedCaptureNum = numCapturesBeforeAG + numAGs;
						expression = `${expression.slice(0, aGPos)}${emulatedAGDelim}${expression.slice(aGPos + 3, index)}))<$$${addedCaptureNum}>)${expression.slice(index + 1)}`;
						hasProcessedAG = true;
						addedHiddenCaptures.push(addedCaptureNum);
						incrementIfAtLeast$1(hiddenCaptures, addedCaptureNum);
						if (captureTransfers.size) {
							const newCaptureTransfers = /* @__PURE__ */ new Map();
							captureTransfers.forEach((from, to) => {
								newCaptureTransfers.set(to >= addedCaptureNum ? to + 1 : to, from.map((f$2) => f$2 >= addedCaptureNum ? f$2 + 1 : f$2));
							});
							captureTransfers = newCaptureTransfers;
						}
						break;
					}
					numGroupsOpenInAG--;
				}
			} else if (m$2 === "]") numCharClassesOpen--;
		}
	} while (hasProcessedAG);
	hiddenCaptures.push(...addedHiddenCaptures);
	expression = replaceUnescaped(expression, String.raw`\\(?<backrefNum>[1-9]\d*)|<\$\$(?<wrappedBackrefNum>\d+)>`, ({ 0: m$2, groups: { backrefNum, wrappedBackrefNum } }) => {
		if (backrefNum) {
			const bNum = +backrefNum;
			if (bNum > captureNumMap.length - 1) throw new Error(`Backref "${m$2}" greater than number of captures`);
			return `\\${captureNumMap[bNum]}`;
		}
		return `\\${wrappedBackrefNum}`;
	}, Context.DEFAULT);
	return {
		pattern: expression,
		captureTransfers,
		hiddenCaptures
	};
}
const baseQuantifier = String.raw`(?:[?*+]|\{\d+(?:,\d*)?\})`;
const possessivePluginToken = new RegExp(String.raw`
\\(?: \d+
  | c[A-Za-z]
  | [gk]<[^>]+>
  | [pPu]\{[^\}]+\}
  | u[A-Fa-f\d]{4}
  | x[A-Fa-f\d]{2}
  )
| \((?: \? (?: [:=!>]
  | <(?:[=!]|[^>]+>)
  | [A-Za-z\-]+:
  | \(DEFINE\)
  ))?
| (?<qBase>${baseQuantifier})(?<qMod>[?+]?)(?<invalidQ>[?*+\{]?)
| \\?.
`.replace(/\s+/g, ""), "gsu");
function possessive(expression) {
	if (!(/* @__PURE__ */ new RegExp(`${baseQuantifier}\\+`)).test(expression)) return { pattern: expression };
	const openGroupIndices = [];
	let lastGroupIndex = null;
	let lastCharClassIndex = null;
	let lastToken = "";
	let numCharClassesOpen = 0;
	let match;
	possessivePluginToken.lastIndex = 0;
	while (match = possessivePluginToken.exec(expression)) {
		const { 0: m$2, index, groups: { qBase, qMod, invalidQ } } = match;
		if (m$2 === "[") {
			if (!numCharClassesOpen) lastCharClassIndex = index;
			numCharClassesOpen++;
		} else if (m$2 === "]") if (numCharClassesOpen) numCharClassesOpen--;
		else lastCharClassIndex = null;
		else if (!numCharClassesOpen) {
			if (qMod === "+" && lastToken && !lastToken.startsWith("(")) {
				if (invalidQ) throw new Error(`Invalid quantifier "${m$2}"`);
				let charsAdded = -1;
				if (/^\{\d+\}$/.test(qBase)) expression = spliceStr(expression, index + qBase.length, qMod, "");
				else {
					if (lastToken === ")" || lastToken === "]") {
						const nodeIndex = lastToken === ")" ? lastGroupIndex : lastCharClassIndex;
						if (nodeIndex === null) throw new Error(`Invalid unmatched "${lastToken}"`);
						expression = `${expression.slice(0, nodeIndex)}(?>${expression.slice(nodeIndex, index)}${qBase})${expression.slice(index + m$2.length)}`;
					} else expression = `${expression.slice(0, index - lastToken.length)}(?>${lastToken}${qBase})${expression.slice(index + m$2.length)}`;
					charsAdded += 4;
				}
				possessivePluginToken.lastIndex += charsAdded;
			} else if (m$2[0] === "(") openGroupIndices.push(index);
			else if (m$2 === ")") lastGroupIndex = openGroupIndices.length ? openGroupIndices.pop() : null;
		}
		lastToken = m$2;
	}
	return { pattern: expression };
}
const r$1 = String.raw;
const gRToken = r$1`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;
const recursiveToken = r$1`\(\?R=(?<rDepth>[^\)]+)\)|${gRToken}`;
const namedCaptureDelim = r$1`\(\?<(?![=!])(?<captureName>[^>]+)>`;
const captureDelim = r$1`${namedCaptureDelim}|(?<unnamed>\()(?!\?)`;
const token = new RegExp(r$1`${namedCaptureDelim}|${recursiveToken}|\(\?|\\?.`, "gsu");
const overlappingRecursionMsg = "Cannot use multiple overlapping recursions";
function recursion(pattern, data) {
	const { hiddenCaptures, mode } = {
		hiddenCaptures: [],
		mode: "plugin",
		...data
	};
	let captureTransfers = data?.captureTransfers ?? /* @__PURE__ */ new Map();
	if (!new RegExp(recursiveToken, "su").test(pattern)) return {
		pattern,
		captureTransfers,
		hiddenCaptures
	};
	if (mode === "plugin" && hasUnescaped(pattern, r$1`\(\?\(DEFINE\)`, Context.DEFAULT)) throw new Error("DEFINE groups cannot be used with recursion");
	const addedHiddenCaptures = [];
	const hasNumberedBackref = hasUnescaped(pattern, r$1`\\[1-9]`, Context.DEFAULT);
	const groupContentsStartPos = /* @__PURE__ */ new Map();
	const openGroups = [];
	let hasRecursed = false;
	let numCharClassesOpen = 0;
	let numCapturesPassed = 0;
	let match;
	token.lastIndex = 0;
	while (match = token.exec(pattern)) {
		const { 0: m$2, groups: { captureName, rDepth, gRNameOrNum, gRDepth } } = match;
		if (m$2 === "[") numCharClassesOpen++;
		else if (!numCharClassesOpen) {
			if (rDepth) {
				assertMaxInBounds(rDepth);
				if (hasRecursed) throw new Error(overlappingRecursionMsg);
				if (hasNumberedBackref) throw new Error(`${mode === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with global recursion`);
				const left = pattern.slice(0, match.index);
				const right = pattern.slice(token.lastIndex);
				if (hasUnescaped(right, recursiveToken, Context.DEFAULT)) throw new Error(overlappingRecursionMsg);
				const reps = +rDepth - 1;
				pattern = makeRecursive(left, right, reps, false, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);
				captureTransfers = mapCaptureTransfers(captureTransfers, left, reps, addedHiddenCaptures.length, 0, numCapturesPassed);
				break;
			} else if (gRNameOrNum) {
				assertMaxInBounds(gRDepth);
				let isWithinReffedGroup = false;
				for (const g of openGroups) if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {
					isWithinReffedGroup = true;
					if (g.hasRecursedWithin) throw new Error(overlappingRecursionMsg);
					break;
				}
				if (!isWithinReffedGroup) throw new Error(r$1`Recursive \g cannot be used outside the referenced group "${mode === "external" ? gRNameOrNum : r$1`\g<${gRNameOrNum}&R=${gRDepth}>`}"`);
				const startPos = groupContentsStartPos.get(gRNameOrNum);
				const groupContents = getGroupContents(pattern, startPos);
				if (hasNumberedBackref && hasUnescaped(groupContents, r$1`${namedCaptureDelim}|\((?!\?)`, Context.DEFAULT)) throw new Error(`${mode === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with recursion of capturing groups`);
				const groupContentsLeft = pattern.slice(startPos, match.index);
				const groupContentsRight = groupContents.slice(groupContentsLeft.length + m$2.length);
				const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;
				const reps = +gRDepth - 1;
				const expansion = makeRecursive(groupContentsLeft, groupContentsRight, reps, true, hiddenCaptures, addedHiddenCaptures, numCapturesPassed);
				captureTransfers = mapCaptureTransfers(captureTransfers, groupContentsLeft, reps, addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed);
				const pre = pattern.slice(0, startPos);
				const post = pattern.slice(startPos + groupContents.length);
				pattern = `${pre}${expansion}${post}`;
				token.lastIndex += expansion.length - m$2.length - groupContentsLeft.length - groupContentsRight.length;
				openGroups.forEach((g) => g.hasRecursedWithin = true);
				hasRecursed = true;
			} else if (captureName) {
				numCapturesPassed++;
				groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
				groupContentsStartPos.set(captureName, token.lastIndex);
				openGroups.push({
					num: numCapturesPassed,
					name: captureName
				});
			} else if (m$2[0] === "(") {
				const isUnnamedCapture = m$2 === "(";
				if (isUnnamedCapture) {
					numCapturesPassed++;
					groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);
				}
				openGroups.push(isUnnamedCapture ? { num: numCapturesPassed } : {});
			} else if (m$2 === ")") openGroups.pop();
		} else if (m$2 === "]") numCharClassesOpen--;
	}
	hiddenCaptures.push(...addedHiddenCaptures);
	return {
		pattern,
		captureTransfers,
		hiddenCaptures
	};
}
function assertMaxInBounds(max) {
	const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;
	if (!/^[1-9]\d*$/.test(max)) throw new Error(errMsg);
	max = +max;
	if (max < 2 || max > 100) throw new Error(errMsg);
}
function makeRecursive(left, right, reps, isSubpattern, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
	const namesInRecursed = /* @__PURE__ */ new Set();
	if (isSubpattern) forEachUnescaped(left + right, namedCaptureDelim, ({ groups: { captureName } }) => {
		namesInRecursed.add(captureName);
	}, Context.DEFAULT);
	const rest = [
		reps,
		isSubpattern ? namesInRecursed : null,
		hiddenCaptures,
		addedHiddenCaptures,
		numCapturesPassed
	];
	return `${left}${repeatWithDepth(`(?:${left}`, "forward", ...rest)}(?:)${repeatWithDepth(`${right})`, "backward", ...rest)}${right}`;
}
function repeatWithDepth(pattern, direction, reps, namesInRecursed, hiddenCaptures, addedHiddenCaptures, numCapturesPassed) {
	const startNum = 2;
	const getDepthNum = (i$1) => direction === "forward" ? i$1 + startNum : reps - i$1 + startNum - 1;
	let result = "";
	for (let i$1 = 0; i$1 < reps; i$1++) {
		const depthNum = getDepthNum(i$1);
		result += replaceUnescaped(pattern, r$1`${captureDelim}|\\k<(?<backref>[^>]+)>`, ({ 0: m$2, groups: { captureName, unnamed, backref } }) => {
			if (backref && namesInRecursed && !namesInRecursed.has(backref)) return m$2;
			const suffix = `_$${depthNum}`;
			if (unnamed || captureName) {
				const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;
				addedHiddenCaptures.push(addedCaptureNum);
				incrementIfAtLeast(hiddenCaptures, addedCaptureNum);
				return unnamed ? m$2 : `(?<${captureName}${suffix}>`;
			}
			return r$1`\k<${backref}${suffix}>`;
		}, Context.DEFAULT);
	}
	return result;
}
function incrementIfAtLeast(arr, threshold) {
	for (let i$1 = 0; i$1 < arr.length; i$1++) if (arr[i$1] >= threshold) arr[i$1]++;
}
function mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {
	if (captureTransfers.size && numCapturesAddedInExpansion) {
		let numCapturesInLeft = 0;
		forEachUnescaped(left, captureDelim, () => numCapturesInLeft++, Context.DEFAULT);
		const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;
		const newCaptureTransfers = /* @__PURE__ */ new Map();
		captureTransfers.forEach((from, to) => {
			const numCapturesInRight = (numCapturesAddedInExpansion - numCapturesInLeft * reps) / reps;
			const numCapturesAddedInLeft = numCapturesInLeft * reps;
			const newTo = to > recursionDelimCaptureNum + numCapturesInLeft ? to + numCapturesAddedInExpansion : to;
			const newFrom = [];
			for (const f$2 of from) if (f$2 <= recursionDelimCaptureNum) newFrom.push(f$2);
			else if (f$2 > recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight) newFrom.push(f$2 + numCapturesAddedInExpansion);
			else if (f$2 <= recursionDelimCaptureNum + numCapturesInLeft) for (let i$1 = 0; i$1 <= reps; i$1++) newFrom.push(f$2 + numCapturesInLeft * i$1);
			else for (let i$1 = 0; i$1 <= reps; i$1++) newFrom.push(f$2 + numCapturesAddedInLeft + numCapturesInRight * i$1);
			newCaptureTransfers.set(newTo, newFrom);
		});
		return newCaptureTransfers;
	}
	return captureTransfers;
}
var cp = String.fromCodePoint;
var r = String.raw;
var envFlags = {
	flagGroups: (() => {
		return true;
	})(),
	unicodeSets: (() => {
		try {
			new RegExp("", "v");
		} catch {
			return false;
		}
		return true;
	})()
};
envFlags.bugFlagVLiteralHyphenIsRange = envFlags.unicodeSets ? (() => {
	try {
		new RegExp(r`[\d\-a]`, "v");
	} catch {
		return true;
	}
	return false;
})() : false;
envFlags.bugNestedClassIgnoresNegation = envFlags.unicodeSets && new RegExp("[[^a]]", "v").test("a");
function getNewCurrentFlags(current, { enable, disable }) {
	return {
		dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),
		ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)
	};
}
function getOrInsert(map, key, defaultValue) {
	if (!map.has(key)) map.set(key, defaultValue);
	return map.get(key);
}
function isMinTarget(target, min) {
	return EsVersion[target] >= EsVersion[min];
}
function throwIfNullish(value, msg) {
	if (value == null) throw new Error(msg ?? "Value expected");
	return value;
}
var EsVersion = {
	ES2025: 2025,
	ES2024: 2024,
	ES2018: 2018
};
var Target = {
	auto: "auto",
	ES2025: "ES2025",
	ES2024: "ES2024",
	ES2018: "ES2018"
};
function getOptions(options = {}) {
	if ({}.toString.call(options) !== "[object Object]") throw new Error("Unexpected options");
	if (options.target !== void 0 && !Target[options.target]) throw new Error(`Unexpected target "${options.target}"`);
	const opts = {
		accuracy: "default",
		avoidSubclass: false,
		flags: "",
		global: false,
		hasIndices: false,
		lazyCompileLength: Infinity,
		target: "auto",
		verbose: false,
		...options,
		rules: {
			allowOrphanBackrefs: false,
			asciiWordBoundaries: false,
			captureGroup: false,
			recursionLimit: 20,
			singleline: false,
			...options.rules
		}
	};
	if (opts.target === "auto") opts.target = envFlags.flagGroups ? "ES2025" : envFlags.unicodeSets ? "ES2024" : "ES2018";
	return opts;
}
var asciiSpaceChar = "[	-\r ]";
var CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([cp(304), cp(305)]);
var defaultWordChar = r`[\p{L}\p{M}\p{N}\p{Pc}]`;
function getIgnoreCaseMatchChars(char) {
	if (CharsWithoutIgnoreCaseExpansion.has(char)) return [char];
	const set = /* @__PURE__ */ new Set();
	const lower = char.toLowerCase();
	const upper = lower.toUpperCase();
	const title = LowerToTitleCaseMap.get(lower);
	const altLower = LowerToAlternativeLowerCaseMap.get(lower);
	const altUpper = LowerToAlternativeUpperCaseMap.get(lower);
	if ([...upper].length === 1) set.add(upper);
	altUpper && set.add(altUpper);
	title && set.add(title);
	set.add(lower);
	altLower && set.add(altLower);
	return [...set];
}
var JsUnicodePropertyMap = /* @__PURE__ */ new Map(`C Other
Cc Control cntrl
Cf Format
Cn Unassigned
Co Private_Use
Cs Surrogate
L Letter
LC Cased_Letter
Ll Lowercase_Letter
Lm Modifier_Letter
Lo Other_Letter
Lt Titlecase_Letter
Lu Uppercase_Letter
M Mark Combining_Mark
Mc Spacing_Mark
Me Enclosing_Mark
Mn Nonspacing_Mark
N Number
Nd Decimal_Number digit
Nl Letter_Number
No Other_Number
P Punctuation punct
Pc Connector_Punctuation
Pd Dash_Punctuation
Pe Close_Punctuation
Pf Final_Punctuation
Pi Initial_Punctuation
Po Other_Punctuation
Ps Open_Punctuation
S Symbol
Sc Currency_Symbol
Sk Modifier_Symbol
Sm Math_Symbol
So Other_Symbol
Z Separator
Zl Line_Separator
Zp Paragraph_Separator
Zs Space_Separator
ASCII
ASCII_Hex_Digit AHex
Alphabetic Alpha
Any
Assigned
Bidi_Control Bidi_C
Bidi_Mirrored Bidi_M
Case_Ignorable CI
Cased
Changes_When_Casefolded CWCF
Changes_When_Casemapped CWCM
Changes_When_Lowercased CWL
Changes_When_NFKC_Casefolded CWKCF
Changes_When_Titlecased CWT
Changes_When_Uppercased CWU
Dash
Default_Ignorable_Code_Point DI
Deprecated Dep
Diacritic Dia
Emoji
Emoji_Component EComp
Emoji_Modifier EMod
Emoji_Modifier_Base EBase
Emoji_Presentation EPres
Extended_Pictographic ExtPict
Extender Ext
Grapheme_Base Gr_Base
Grapheme_Extend Gr_Ext
Hex_Digit Hex
IDS_Binary_Operator IDSB
IDS_Trinary_Operator IDST
ID_Continue IDC
ID_Start IDS
Ideographic Ideo
Join_Control Join_C
Logical_Order_Exception LOE
Lowercase Lower
Math
Noncharacter_Code_Point NChar
Pattern_Syntax Pat_Syn
Pattern_White_Space Pat_WS
Quotation_Mark QMark
Radical
Regional_Indicator RI
Sentence_Terminal STerm
Soft_Dotted SD
Terminal_Punctuation Term
Unified_Ideograph UIdeo
Uppercase Upper
Variation_Selector VS
White_Space space
XID_Continue XIDC
XID_Start XIDS`.split(/\s/).map((p) => [w(p), p]));
var LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([["s", cp(383)], [cp(383), "s"]]);
var LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([
	[cp(223), cp(7838)],
	[cp(107), cp(8490)],
	[cp(229), cp(8491)],
	[cp(969), cp(8486)]
]);
var LowerToTitleCaseMap = new Map([
	titleEntry(453),
	titleEntry(456),
	titleEntry(459),
	titleEntry(498),
	...titleRange(8072, 8079),
	...titleRange(8088, 8095),
	...titleRange(8104, 8111),
	titleEntry(8124),
	titleEntry(8140),
	titleEntry(8188)
]);
var PosixClassMap = /* @__PURE__ */ new Map([
	["alnum", r`[\p{Alpha}\p{Nd}]`],
	["alpha", r`\p{Alpha}`],
	["ascii", r`\p{ASCII}`],
	["blank", r`[\p{Zs}\t]`],
	["cntrl", r`\p{Cc}`],
	["digit", r`\p{Nd}`],
	["graph", r`[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]`],
	["lower", r`\p{Lower}`],
	["print", r`[[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]\p{Zs}]`],
	["punct", r`[\p{P}\p{S}]`],
	["space", r`\p{space}`],
	["upper", r`\p{Upper}`],
	["word", r`[\p{Alpha}\p{M}\p{Nd}\p{Pc}]`],
	["xdigit", r`\p{AHex}`]
]);
function range(start, end) {
	const range2 = [];
	for (let i$1 = start; i$1 <= end; i$1++) range2.push(i$1);
	return range2;
}
function titleEntry(codePoint) {
	const char = cp(codePoint);
	return [char.toLowerCase(), char];
}
function titleRange(start, end) {
	return range(start, end).map((codePoint) => titleEntry(codePoint));
}
var UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([
	"Lower",
	"Lowercase",
	"Upper",
	"Uppercase",
	"Ll",
	"Lowercase_Letter",
	"Lt",
	"Titlecase_Letter",
	"Lu",
	"Uppercase_Letter"
]);
function transform(ast, options) {
	const opts = {
		accuracy: "default",
		asciiWordBoundaries: false,
		avoidSubclass: false,
		bestEffortTarget: "ES2025",
		...options
	};
	addParentProperties(ast);
	const firstPassState = {
		accuracy: opts.accuracy,
		asciiWordBoundaries: opts.asciiWordBoundaries,
		avoidSubclass: opts.avoidSubclass,
		flagDirectivesByAlt: /* @__PURE__ */ new Map(),
		jsGroupNameMap: /* @__PURE__ */ new Map(),
		minTargetEs2024: isMinTarget(opts.bestEffortTarget, "ES2024"),
		passedLookbehind: false,
		strategy: null,
		subroutineRefMap: /* @__PURE__ */ new Map(),
		supportedGNodes: /* @__PURE__ */ new Set(),
		digitIsAscii: ast.flags.digitIsAscii,
		spaceIsAscii: ast.flags.spaceIsAscii,
		wordIsAscii: ast.flags.wordIsAscii
	};
	S(ast, FirstPassVisitor, firstPassState);
	const globalFlags = {
		dotAll: ast.flags.dotAll,
		ignoreCase: ast.flags.ignoreCase
	};
	const secondPassState = {
		currentFlags: globalFlags,
		prevFlags: null,
		globalFlags,
		groupOriginByCopy: /* @__PURE__ */ new Map(),
		groupsByName: /* @__PURE__ */ new Map(),
		multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),
		openRefs: /* @__PURE__ */ new Map(),
		reffedNodesByReferencer: /* @__PURE__ */ new Map(),
		subroutineRefMap: firstPassState.subroutineRefMap
	};
	S(ast, SecondPassVisitor, secondPassState);
	const thirdPassState = {
		groupsByName: secondPassState.groupsByName,
		highestOrphanBackref: 0,
		numCapturesToLeft: 0,
		reffedNodesByReferencer: secondPassState.reffedNodesByReferencer
	};
	S(ast, ThirdPassVisitor, thirdPassState);
	ast._originMap = secondPassState.groupOriginByCopy;
	ast._strategy = firstPassState.strategy;
	return ast;
}
var FirstPassVisitor = {
	AbsenceFunction({ node, parent, replaceWith }) {
		const { body, kind } = node;
		if (kind === "repeater") {
			const innerGroup = A();
			innerGroup.body[0].body.push(K({
				negate: true,
				body
			}), Q("Any"));
			const outerGroup = A();
			outerGroup.body[0].body.push(_("greedy", 0, Infinity, innerGroup));
			replaceWith(setParentDeep(outerGroup, parent), { traverse: true });
		} else throw new Error(`Unsupported absence function "(?~|"`);
	},
	Alternative: {
		enter({ node, parent, key }, { flagDirectivesByAlt }) {
			const flagDirectives = node.body.filter((el) => el.kind === "flags");
			for (let i$1 = key + 1; i$1 < parent.body.length; i$1++) {
				const forwardSiblingAlt = parent.body[i$1];
				getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);
			}
		},
		exit({ node }, { flagDirectivesByAlt }) {
			if (flagDirectivesByAlt.get(node)?.length) {
				const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));
				if (flags) {
					const flagGroup = A({ flags });
					flagGroup.body[0].body = node.body;
					node.body = [setParentDeep(flagGroup, node)];
				}
			}
		}
	},
	Assertion({ node, parent, key, container, root, remove, replaceWith }, state) {
		const { kind, negate } = node;
		const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;
		if (kind === "text_segment_boundary") throw new Error(`Unsupported text segment boundary "\\${negate ? "Y" : "y"}"`);
		else if (kind === "line_end") replaceWith(setParentDeep(K({ body: [b({ body: [F("string_end")] }), b({ body: [m(10)] })] }), parent));
		else if (kind === "line_start") replaceWith(setParentDeep(parseFragment(r`(?<=\A|\n(?!\z))`, { skipLookbehindValidation: true }), parent));
		else if (kind === "search_start") if (supportedGNodes.has(node)) {
			root.flags.sticky = true;
			remove();
		} else {
			const prev = container[key - 1];
			if (prev && isAlwaysNonZeroLength(prev)) replaceWith(setParentDeep(K({ negate: true }), parent));
			else if (avoidSubclass) throw new Error(r`Uses "\G" in a way that requires a subclass`);
			else {
				replaceWith(setParent(F("string_start"), parent));
				state.strategy = "clip_search";
			}
		}
		else if (kind === "string_end" || kind === "string_start") {} else if (kind === "string_end_newline") replaceWith(setParentDeep(parseFragment(r`(?=\n?\z)`), parent));
		else if (kind === "word_boundary") {
			if (!wordIsAscii && !asciiWordBoundaries) {
				const b$2 = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;
				const B$2 = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;
				replaceWith(setParentDeep(parseFragment(negate ? B$2 : b$2), parent));
			}
		} else throw new Error(`Unexpected assertion kind "${kind}"`);
	},
	Backreference({ node }, { jsGroupNameMap }) {
		let { ref } = node;
		if (typeof ref === "string" && !isValidJsGroupName(ref)) {
			ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
			node.ref = ref;
		}
	},
	CapturingGroup({ node }, { jsGroupNameMap, subroutineRefMap }) {
		let { name } = node;
		if (name && !isValidJsGroupName(name)) {
			name = getAndStoreJsGroupName(name, jsGroupNameMap);
			node.name = name;
		}
		subroutineRefMap.set(node.number, node);
		if (name) subroutineRefMap.set(name, node);
	},
	CharacterClassRange({ node, parent, replaceWith }) {
		if (parent.kind === "intersection") {
			const cc = C({ body: [node] });
			replaceWith(setParentDeep(cc, parent), { traverse: true });
		}
	},
	CharacterSet({ node, parent, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {
		const { kind, negate, value } = node;
		if (digitIsAscii && (kind === "digit" || value === "digit")) {
			replaceWith(setParent(E("digit", { negate }), parent));
			return;
		}
		if (spaceIsAscii && (kind === "space" || value === "space")) {
			replaceWith(setParentDeep(setNegate(parseFragment(asciiSpaceChar), negate), parent));
			return;
		}
		if (wordIsAscii && (kind === "word" || value === "word")) {
			replaceWith(setParent(E("word", { negate }), parent));
			return;
		}
		if (kind === "any") replaceWith(setParent(Q("Any"), parent));
		else if (kind === "digit") replaceWith(setParent(Q("Nd", { negate }), parent));
		else if (kind === "dot") {} else if (kind === "text_segment") {
			if (accuracy === "strict") throw new Error(r`Use of "\X" requires non-strict accuracy`);
			const eBase = "\\p{Emoji}(?:\\p{EMod}|\\uFE0F\\u20E3?|[\\x{E0020}-\\x{E007E}]+\\x{E007F})?";
			const emoji = r`\p{RI}{2}|${eBase}(?:\u200D${eBase})*`;
			replaceWith(setParentDeep(parseFragment(r`(?>\r\n|${minTargetEs2024 ? r`\p{RGI_Emoji}` : emoji}|\P{M}\p{M}*)`, { skipPropertyNameValidation: true }), parent));
		} else if (kind === "hex") replaceWith(setParent(Q("AHex", { negate }), parent));
		else if (kind === "newline") replaceWith(setParentDeep(parseFragment(negate ? "[^\n]" : "(?>\r\n?|[\n\v\f\u2028\u2029])"), parent));
		else if (kind === "posix") if (!minTargetEs2024 && (value === "graph" || value === "print")) {
			if (accuracy === "strict") throw new Error(`POSIX class "${value}" requires min target ES2024 or non-strict accuracy`);
			let ascii = {
				graph: "!-~",
				print: " -~"
			}[value];
			if (negate) ascii = `\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\u{10FFFF}`;
			replaceWith(setParentDeep(parseFragment(`[${ascii}]`), parent));
		} else replaceWith(setParentDeep(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));
		else if (kind === "property") {
			if (!JsUnicodePropertyMap.has(w(value))) node.key = "sc";
		} else if (kind === "space") replaceWith(setParent(Q("space", { negate }), parent));
		else if (kind === "word") replaceWith(setParentDeep(setNegate(parseFragment(defaultWordChar), negate), parent));
		else throw new Error(`Unexpected character set kind "${kind}"`);
	},
	Directive({ node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings }) {
		const { kind, flags } = node;
		if (kind === "flags") if (!flags.enable && !flags.disable) remove();
		else {
			const flagGroup = A({ flags });
			flagGroup.body[0].body = removeAllNextSiblings();
			replaceWith(setParentDeep(flagGroup, parent), { traverse: true });
		}
		else if (kind === "keep") {
			const firstAlt = root.body[0];
			const hasWrapperGroup = root.body.length === 1 && o(firstAlt, { type: "Group" }) && firstAlt.body[0].body.length === 1;
			const topLevel = hasWrapperGroup ? firstAlt.body[0] : root;
			if (parent.parent !== topLevel || topLevel.body.length > 1) throw new Error(r`Uses "\K" in a way that's unsupported`);
			const lookbehind = K({ behind: true });
			lookbehind.body[0].body = removeAllPrevSiblings();
			replaceWith(setParentDeep(lookbehind, parent));
		} else throw new Error(`Unexpected directive kind "${kind}"`);
	},
	Flags({ node, parent }) {
		if (node.posixIsAscii) throw new Error("Unsupported flag \"P\"");
		if (node.textSegmentMode === "word") throw new Error("Unsupported flag \"y{w}\"");
		[
			"digitIsAscii",
			"extended",
			"posixIsAscii",
			"spaceIsAscii",
			"wordIsAscii",
			"textSegmentMode"
		].forEach((f$2) => delete node[f$2]);
		Object.assign(node, {
			global: false,
			hasIndices: false,
			multiline: false,
			sticky: node.sticky ?? false
		});
		parent.options = {
			disable: {
				x: true,
				n: true
			},
			force: { v: true }
		};
	},
	Group({ node }) {
		if (!node.flags) return;
		const { enable, disable } = node.flags;
		enable?.extended && delete enable.extended;
		disable?.extended && delete disable.extended;
		enable?.dotAll && disable?.dotAll && delete enable.dotAll;
		enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;
		enable && !Object.keys(enable).length && delete node.flags.enable;
		disable && !Object.keys(disable).length && delete node.flags.disable;
		!node.flags.enable && !node.flags.disable && delete node.flags;
	},
	LookaroundAssertion({ node }, state) {
		const { kind } = node;
		if (kind === "lookbehind") state.passedLookbehind = true;
	},
	NamedCallout({ node, parent, replaceWith }) {
		const { kind } = node;
		if (kind === "fail") replaceWith(setParentDeep(K({ negate: true }), parent));
		else throw new Error(`Unsupported named callout "(*${kind.toUpperCase()}"`);
	},
	Quantifier({ node }) {
		if (node.body.type === "Quantifier") {
			const group = A();
			group.body[0].body.push(node.body);
			node.body = setParentDeep(group, node);
		}
	},
	Regex: {
		enter({ node }, { supportedGNodes }) {
			const leadingGs = [];
			let hasAltWithLeadG = false;
			let hasAltWithoutLeadG = false;
			for (const alt of node.body) if (alt.body.length === 1 && alt.body[0].kind === "search_start") alt.body.pop();
			else {
				const leadingG = getLeadingG(alt.body);
				if (leadingG) {
					hasAltWithLeadG = true;
					Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);
				} else hasAltWithoutLeadG = true;
			}
			if (hasAltWithLeadG && !hasAltWithoutLeadG) leadingGs.forEach((g) => supportedGNodes.add(g));
		},
		exit(_$2, { accuracy, passedLookbehind, strategy }) {
			if (accuracy === "strict" && passedLookbehind && strategy) throw new Error(r`Uses "\G" in a way that requires non-strict accuracy`);
		}
	},
	Subroutine({ node }, { jsGroupNameMap }) {
		let { ref } = node;
		if (typeof ref === "string" && !isValidJsGroupName(ref)) {
			ref = getAndStoreJsGroupName(ref, jsGroupNameMap);
			node.ref = ref;
		}
	}
};
var SecondPassVisitor = {
	Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {
		const { orphan, ref } = node;
		if (!orphan) reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);
	},
	CapturingGroup: {
		enter({ node, parent, replaceWith, skip }, { groupOriginByCopy, groupsByName, multiplexCapturesToLeftByRef, openRefs, reffedNodesByReferencer }) {
			const origin = groupOriginByCopy.get(node);
			if (origin && openRefs.has(node.number)) {
				const recursion2 = setParent(createRecursion(node.number), parent);
				reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));
				replaceWith(recursion2);
				return;
			}
			openRefs.set(node.number, node);
			multiplexCapturesToLeftByRef.set(node.number, []);
			if (node.name) getOrInsert(multiplexCapturesToLeftByRef, node.name, []);
			const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);
			for (let i$1 = 0; i$1 < multiplexNodes.length; i$1++) {
				const multiplex = multiplexNodes[i$1];
				if (origin === multiplex.node || origin && origin === multiplex.origin || node === multiplex.origin) {
					multiplexNodes.splice(i$1, 1);
					break;
				}
			}
			multiplexCapturesToLeftByRef.get(node.number).push({
				node,
				origin
			});
			if (node.name) multiplexCapturesToLeftByRef.get(node.name).push({
				node,
				origin
			});
			if (node.name) {
				const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());
				let hasDuplicateNameToRemove = false;
				if (origin) hasDuplicateNameToRemove = true;
				else for (const groupInfo of groupsWithSameName.values()) if (!groupInfo.hasDuplicateNameToRemove) {
					hasDuplicateNameToRemove = true;
					break;
				}
				groupsByName.get(node.name).set(node, {
					node,
					hasDuplicateNameToRemove
				});
			}
		},
		exit({ node }, { openRefs }) {
			openRefs.delete(node.number);
		}
	},
	Group: {
		enter({ node }, state) {
			state.prevFlags = state.currentFlags;
			if (node.flags) state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);
		},
		exit(_$2, state) {
			state.currentFlags = state.prevFlags;
		}
	},
	Subroutine({ node, parent, replaceWith }, state) {
		const { isRecursive, ref } = node;
		if (isRecursive) {
			let reffed = parent;
			while (reffed = reffed.parent) if (reffed.type === "CapturingGroup" && (reffed.name === ref || reffed.number === ref)) break;
			state.reffedNodesByReferencer.set(node, reffed);
			return;
		}
		const reffedGroupNode = state.subroutineRefMap.get(ref);
		const isGlobalRecursion = ref === 0;
		const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);
		let replacement = expandedSubroutine;
		if (!isGlobalRecursion) {
			const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (p) => p.type === "Group" && !!p.flags));
			const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;
			if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {
				replacement = A({ flags: getFlagModsFromFlags(reffedGroupFlags) });
				replacement.body[0].body.push(expandedSubroutine);
			}
		}
		replaceWith(setParentDeep(replacement, parent), { traverse: !isGlobalRecursion });
	}
};
var ThirdPassVisitor = {
	Backreference({ node, parent, replaceWith }, state) {
		if (node.orphan) {
			state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);
			return;
		}
		const reffedNodes = state.reffedNodesByReferencer.get(node);
		const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node));
		if (!participants.length) replaceWith(setParentDeep(K({ negate: true }), parent));
		else if (participants.length > 1) {
			const group = A({
				atomic: true,
				body: participants.reverse().map((reffed) => b({ body: [k(reffed.number)] }))
			});
			replaceWith(setParentDeep(group, parent));
		} else node.ref = participants[0].number;
	},
	CapturingGroup({ node }, state) {
		node.number = ++state.numCapturesToLeft;
		if (node.name) {
			if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) delete node.name;
		}
	},
	Regex: { exit({ node }, state) {
		const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);
		for (let i$1 = 0; i$1 < numCapsNeeded; i$1++) {
			const emptyCapture = P();
			node.body.at(-1).body.push(emptyCapture);
		}
	} },
	Subroutine({ node }, state) {
		if (!node.isRecursive || node.ref === 0) return;
		node.ref = state.reffedNodesByReferencer.get(node).number;
	}
};
function addParentProperties(root) {
	S(root, { "*"({ node, parent }) {
		node.parent = parent;
	} });
}
function areFlagsEqual(a$1, b$2) {
	return a$1.dotAll === b$2.dotAll && a$1.ignoreCase === b$2.ignoreCase;
}
function canParticipateWithNode(capture, node) {
	let rightmostPoint = node;
	do {
		if (rightmostPoint.type === "Regex") return false;
		if (rightmostPoint.type === "Alternative") continue;
		if (rightmostPoint === capture) return false;
		const kidsOfParent = getKids(rightmostPoint.parent);
		for (const kid of kidsOfParent) {
			if (kid === rightmostPoint) break;
			if (kid === capture || isAncestorOf(kid, capture)) return true;
		}
	} while (rightmostPoint = rightmostPoint.parent);
	throw new Error("Unexpected path");
}
function cloneCapturingGroup(obj, originMap, up, up2) {
	const store = Array.isArray(obj) ? [] : {};
	for (const [key, value] of Object.entries(obj)) if (key === "parent") store.parent = Array.isArray(up) ? up2 : up;
	else if (value && typeof value === "object") store[key] = cloneCapturingGroup(value, originMap, store, up);
	else {
		if (key === "type" && value === "CapturingGroup") originMap.set(store, originMap.get(obj) ?? obj);
		store[key] = value;
	}
	return store;
}
function createRecursion(ref) {
	const node = O(ref);
	node.isRecursive = true;
	return node;
}
function getAllParents(node, filterFn) {
	const results = [];
	while (node = node.parent) if (!filterFn || filterFn(node)) results.push(node);
	return results;
}
function getAndStoreJsGroupName(name, map) {
	if (map.has(name)) return map.get(name);
	const jsName = `$${map.size}_${name.replace(/^[^$_\p{IDS}]|[^$\u200C\u200D\p{IDC}]/gu, "_")}`;
	map.set(name, jsName);
	return jsName;
}
function getCombinedFlagModsFromFlagNodes(flagNodes) {
	const flagProps = ["dotAll", "ignoreCase"];
	const combinedFlags = {
		enable: {},
		disable: {}
	};
	flagNodes.forEach(({ flags }) => {
		flagProps.forEach((prop) => {
			if (flags.enable?.[prop]) {
				delete combinedFlags.disable[prop];
				combinedFlags.enable[prop] = true;
			}
			if (flags.disable?.[prop]) combinedFlags.disable[prop] = true;
		});
	});
	if (!Object.keys(combinedFlags.enable).length) delete combinedFlags.enable;
	if (!Object.keys(combinedFlags.disable).length) delete combinedFlags.disable;
	if (combinedFlags.enable || combinedFlags.disable) return combinedFlags;
	return null;
}
function getFlagModsFromFlags({ dotAll, ignoreCase }) {
	const mods = {};
	if (dotAll || ignoreCase) {
		mods.enable = {};
		dotAll && (mods.enable.dotAll = true);
		ignoreCase && (mods.enable.ignoreCase = true);
	}
	if (!dotAll || !ignoreCase) {
		mods.disable = {};
		!dotAll && (mods.disable.dotAll = true);
		!ignoreCase && (mods.disable.ignoreCase = true);
	}
	return mods;
}
function getKids(node) {
	if (!node) throw new Error("Node expected");
	const { body } = node;
	return Array.isArray(body) ? body : body ? [body] : null;
}
function getLeadingG(els) {
	const firstToConsider = els.find((el) => el.kind === "search_start" || isLoneGLookaround(el, { negate: false }) || !isAlwaysZeroLength(el));
	if (!firstToConsider) return null;
	if (firstToConsider.kind === "search_start") return firstToConsider;
	if (firstToConsider.type === "LookaroundAssertion") return firstToConsider.body[0].body[0];
	if (firstToConsider.type === "CapturingGroup" || firstToConsider.type === "Group") {
		const gNodesForGroup = [];
		for (const alt of firstToConsider.body) {
			const leadingG = getLeadingG(alt.body);
			if (!leadingG) return null;
			Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);
		}
		return gNodesForGroup;
	}
	return null;
}
function isAncestorOf(node, descendant) {
	const kids = getKids(node) ?? [];
	for (const kid of kids) if (kid === descendant || isAncestorOf(kid, descendant)) return true;
	return false;
}
function isAlwaysZeroLength({ type }) {
	return type === "Assertion" || type === "Directive" || type === "LookaroundAssertion";
}
function isAlwaysNonZeroLength(node) {
	const types = [
		"Character",
		"CharacterClass",
		"CharacterSet"
	];
	return types.includes(node.type) || node.type === "Quantifier" && node.min && types.includes(node.body.type);
}
function isLoneGLookaround(node, options) {
	const opts = {
		negate: null,
		...options
	};
	return node.type === "LookaroundAssertion" && (opts.negate === null || node.negate === opts.negate) && node.body.length === 1 && o(node.body[0], {
		type: "Assertion",
		kind: "search_start"
	});
}
function isValidJsGroupName(name) {
	return /^[$_\p{IDS}][$\u200C\u200D\p{IDC}]*$/u.test(name);
}
function parseFragment(pattern, options) {
	const ast = J(pattern, {
		...options,
		unicodePropertyMap: JsUnicodePropertyMap
	});
	const alts = ast.body;
	if (alts.length > 1 || alts[0].body.length > 1) return A({ body: alts });
	return alts[0].body[0];
}
function setNegate(node, negate) {
	node.negate = negate;
	return node;
}
function setParent(node, parent) {
	node.parent = parent;
	return node;
}
function setParentDeep(node, parent) {
	addParentProperties(node);
	node.parent = parent;
	return node;
}
function generate(ast, options) {
	const opts = getOptions(options);
	const minTargetEs2024 = isMinTarget(opts.target, "ES2024");
	const minTargetEs2025 = isMinTarget(opts.target, "ES2025");
	const recursionLimit = opts.rules.recursionLimit;
	if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) throw new Error("Invalid recursionLimit; use 2-20");
	let hasCaseInsensitiveNode = null;
	let hasCaseSensitiveNode = null;
	if (!minTargetEs2025) {
		const iStack = [ast.flags.ignoreCase];
		S(ast, FlagModifierVisitor, {
			getCurrentModI: () => iStack.at(-1),
			popModI() {
				iStack.pop();
			},
			pushModI(isIOn) {
				iStack.push(isIOn);
			},
			setHasCasedChar() {
				if (iStack.at(-1)) hasCaseInsensitiveNode = true;
				else hasCaseSensitiveNode = true;
			}
		});
	}
	const appliedGlobalFlags = {
		dotAll: ast.flags.dotAll,
		ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)
	};
	let lastNode = ast;
	const state = {
		accuracy: opts.accuracy,
		appliedGlobalFlags,
		captureMap: /* @__PURE__ */ new Map(),
		currentFlags: {
			dotAll: ast.flags.dotAll,
			ignoreCase: ast.flags.ignoreCase
		},
		inCharClass: false,
		lastNode,
		originMap: ast._originMap,
		recursionLimit,
		useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),
		useFlagMods: minTargetEs2025,
		useFlagV: minTargetEs2024,
		verbose: opts.verbose
	};
	function gen(node) {
		state.lastNode = lastNode;
		lastNode = node;
		const fn = throwIfNullish(generator[node.type], `Unexpected node type "${node.type}"`);
		return fn(node, state, gen);
	}
	const result = {
		pattern: ast.body.map(gen).join("|"),
		flags: gen(ast.flags),
		options: { ...ast.options }
	};
	if (!minTargetEs2024) {
		delete result.options.force.v;
		result.options.disable.v = true;
		result.options.unicodeSetsPlugin = null;
	}
	result._captureTransfers = /* @__PURE__ */ new Map();
	result._hiddenCaptures = [];
	state.captureMap.forEach((value, key) => {
		if (value.hidden) result._hiddenCaptures.push(key);
		if (value.transferTo) getOrInsert(result._captureTransfers, value.transferTo, []).push(key);
	});
	return result;
}
var FlagModifierVisitor = {
	"*": {
		enter({ node }, state) {
			if (isAnyGroup(node)) {
				const currentModI = state.getCurrentModI();
				state.pushModI(node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI);
			}
		},
		exit({ node }, state) {
			if (isAnyGroup(node)) state.popModI();
		}
	},
	Backreference(_$2, state) {
		state.setHasCasedChar();
	},
	Character({ node }, state) {
		if (charHasCase(cp(node.value))) state.setHasCasedChar();
	},
	CharacterClassRange({ node, skip }, state) {
		skip();
		if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) state.setHasCasedChar();
	},
	CharacterSet({ node }, state) {
		if (node.kind === "property" && UnicodePropertiesWithSpecificCase.has(node.value)) state.setHasCasedChar();
	}
};
var generator = {
	Alternative({ body }, _$2, gen) {
		return body.map(gen).join("");
	},
	Assertion({ kind, negate }) {
		if (kind === "string_end") return "$";
		if (kind === "string_start") return "^";
		if (kind === "word_boundary") return negate ? r`\B` : r`\b`;
		throw new Error(`Unexpected assertion kind "${kind}"`);
	},
	Backreference({ ref }, state) {
		if (typeof ref !== "number") throw new Error("Unexpected named backref in transformed AST");
		if (!state.useFlagMods && state.accuracy === "strict" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) throw new Error("Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy");
		return "\\" + ref;
	},
	CapturingGroup(node, state, gen) {
		const { body, name, number } = node;
		const data = { ignoreCase: state.currentFlags.ignoreCase };
		const origin = state.originMap.get(node);
		if (origin) {
			data.hidden = true;
			if (number > origin.number) data.transferTo = origin.number;
		}
		state.captureMap.set(number, data);
		return `(${name ? `?<${name}>` : ""}${body.map(gen).join("|")})`;
	},
	Character({ value }, state) {
		const char = cp(value);
		const escaped = getCharEscape(value, {
			escDigit: state.lastNode.type === "Backreference",
			inCharClass: state.inCharClass,
			useFlagV: state.useFlagV
		});
		if (escaped !== char) return escaped;
		if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {
			const cases = getIgnoreCaseMatchChars(char);
			return state.inCharClass ? cases.join("") : cases.length > 1 ? `[${cases.join("")}]` : cases[0];
		}
		return char;
	},
	CharacterClass(node, state, gen) {
		const { kind, negate, parent } = node;
		let { body } = node;
		if (kind === "intersection" && !state.useFlagV) throw new Error("Use of class intersection requires min target ES2024");
		if (envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV && body.some(isLiteralHyphen)) body = [m(45), ...body.filter((kid) => !isLiteralHyphen(kid))];
		const genClass = () => `[${negate ? "^" : ""}${body.map(gen).join(kind === "intersection" ? "&&" : "")}]`;
		if (!state.inCharClass) {
			if ((!state.useFlagV || envFlags.bugNestedClassIgnoresNegation) && !negate) {
				const negatedChildClasses = body.filter((kid) => kid.type === "CharacterClass" && kid.kind === "union" && kid.negate);
				if (negatedChildClasses.length) {
					const group = A();
					const groupFirstAlt = group.body[0];
					group.parent = parent;
					groupFirstAlt.parent = group;
					body = body.filter((kid) => !negatedChildClasses.includes(kid));
					node.body = body;
					if (body.length) {
						node.parent = groupFirstAlt;
						groupFirstAlt.body.push(node);
					} else group.body.pop();
					negatedChildClasses.forEach((cc) => {
						const newAlt = b({ body: [cc] });
						cc.parent = newAlt;
						newAlt.parent = group;
						group.body.push(newAlt);
					});
					return gen(group);
				}
			}
			state.inCharClass = true;
			const result = genClass();
			state.inCharClass = false;
			return result;
		}
		const firstEl = body[0];
		if (kind === "union" && !negate && firstEl && ((!state.useFlagV || !state.verbose) && parent.kind === "union" && !(envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV) || !state.verbose && parent.kind === "intersection" && body.length === 1 && firstEl.type !== "CharacterClassRange")) return body.map(gen).join("");
		if (!state.useFlagV && parent.type === "CharacterClass") throw new Error("Use of nested character class requires min target ES2024");
		return genClass();
	},
	CharacterClassRange(node, state) {
		const min = node.min.value;
		const max = node.max.value;
		const escOpts = {
			escDigit: false,
			inCharClass: true,
			useFlagV: state.useFlagV
		};
		const minStr = getCharEscape(min, escOpts);
		const maxStr = getCharEscape(max, escOpts);
		const extraChars = /* @__PURE__ */ new Set();
		if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {
			const charsOutsideRange = getCasesOutsideCharClassRange(node);
			const ranges = getCodePointRangesFromChars(charsOutsideRange);
			ranges.forEach((value) => {
				extraChars.add(Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts));
			});
		}
		return `${minStr}-${maxStr}${[...extraChars].join("")}`;
	},
	CharacterSet({ kind, negate, value, key }, state) {
		if (kind === "dot") return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? "." : "[^]" : r`[^\n]`;
		if (kind === "digit") return negate ? r`\D` : r`\d`;
		if (kind === "property") {
			if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) throw new Error(`Unicode property "${value}" can't be case-insensitive when other chars have specific case`);
			return `${negate ? r`\P` : r`\p`}{${key ? `${key}=` : ""}${value}}`;
		}
		if (kind === "word") return negate ? r`\W` : r`\w`;
		throw new Error(`Unexpected character set kind "${kind}"`);
	},
	Flags(node, state) {
		return (state.appliedGlobalFlags.ignoreCase ? "i" : "") + (node.dotAll ? "s" : "") + (node.sticky ? "y" : "");
	},
	Group({ atomic: atomic2, body, flags, parent }, state, gen) {
		const currentFlags = state.currentFlags;
		if (flags) state.currentFlags = getNewCurrentFlags(currentFlags, flags);
		const contents = body.map(gen).join("|");
		const result = !state.verbose && body.length === 1 && parent.type !== "Quantifier" && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;
		state.currentFlags = currentFlags;
		return result;
	},
	LookaroundAssertion({ body, kind, negate }, _$2, gen) {
		const prefix = `${kind === "lookahead" ? "" : "<"}${negate ? "!" : "="}`;
		return `(?${prefix}${body.map(gen).join("|")})`;
	},
	Quantifier(node, _$2, gen) {
		return gen(node.body) + getQuantifierStr(node);
	},
	Subroutine({ isRecursive, ref }, state) {
		if (!isRecursive) throw new Error("Unexpected non-recursive subroutine in transformed AST");
		const limit = state.recursionLimit;
		return ref === 0 ? `(?R=${limit})` : r`\g<${ref}&R=${limit}>`;
	}
};
var BaseEscapeChars = /* @__PURE__ */ new Set([
	"$",
	"(",
	")",
	"*",
	"+",
	".",
	"?",
	"[",
	"\\",
	"]",
	"^",
	"{",
	"|",
	"}"
]);
var CharClassEscapeChars = /* @__PURE__ */ new Set([
	"-",
	"\\",
	"]",
	"^",
	"["
]);
var CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([
	"(",
	")",
	"-",
	"/",
	"[",
	"\\",
	"]",
	"^",
	"{",
	"|",
	"}",
	"!",
	"#",
	"$",
	"%",
	"&",
	"*",
	"+",
	",",
	".",
	":",
	";",
	"<",
	"=",
	">",
	"?",
	"@",
	"`",
	"~"
]);
var CharCodeEscapeMap = /* @__PURE__ */ new Map([
	[9, r`\t`],
	[10, r`\n`],
	[11, r`\v`],
	[12, r`\f`],
	[13, r`\r`],
	[8232, r`\u2028`],
	[8233, r`\u2029`],
	[65279, r`\uFEFF`]
]);
var casedRe = /^\p{Cased}$/u;
function charHasCase(char) {
	return casedRe.test(char);
}
function getCasesOutsideCharClassRange(node, options) {
	const firstOnly = !!options?.firstOnly;
	const min = node.min.value;
	const max = node.max.value;
	const found = [];
	if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) return found;
	for (let i$1 = min; i$1 <= max; i$1++) {
		const char = cp(i$1);
		if (!charHasCase(char)) continue;
		const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {
			const num = caseOfChar.codePointAt(0);
			return num < min || num > max;
		});
		if (charsOutsideRange.length) {
			found.push(...charsOutsideRange);
			if (firstOnly) break;
		}
	}
	return found;
}
function getCharEscape(codePoint, { escDigit, inCharClass, useFlagV }) {
	if (CharCodeEscapeMap.has(codePoint)) return CharCodeEscapeMap.get(codePoint);
	if (codePoint < 32 || codePoint > 126 && codePoint < 160 || codePoint > 262143 || escDigit && isDigitCharCode(codePoint)) return codePoint > 255 ? `\\u{${codePoint.toString(16).toUpperCase()}}` : `\\x${codePoint.toString(16).toUpperCase().padStart(2, "0")}`;
	const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;
	const char = cp(codePoint);
	return (escapeChars.has(char) ? "\\" : "") + char;
}
function getCodePointRangesFromChars(chars) {
	const codePoints = chars.map((char) => char.codePointAt(0)).sort((a$1, b$2) => a$1 - b$2);
	const values = [];
	let start = null;
	for (let i$1 = 0; i$1 < codePoints.length; i$1++) if (codePoints[i$1 + 1] === codePoints[i$1] + 1) start ??= codePoints[i$1];
	else if (start === null) values.push(codePoints[i$1]);
	else {
		values.push([start, codePoints[i$1]]);
		start = null;
	}
	return values;
}
function getGroupPrefix(atomic2, flagMods, useFlagMods) {
	if (atomic2) return ">";
	let mods = "";
	if (flagMods && useFlagMods) {
		const { enable, disable } = flagMods;
		mods = (enable?.ignoreCase ? "i" : "") + (enable?.dotAll ? "s" : "") + (disable ? "-" : "") + (disable?.ignoreCase ? "i" : "") + (disable?.dotAll ? "s" : "");
	}
	return `${mods}:`;
}
function getQuantifierStr({ kind, max, min }) {
	let base;
	if (!min && max === 1) base = "?";
	else if (!min && max === Infinity) base = "*";
	else if (min === 1 && max === Infinity) base = "+";
	else if (min === max) base = `{${min}}`;
	else base = `{${min},${max === Infinity ? "" : max}}`;
	return base + {
		greedy: "",
		lazy: "?",
		possessive: "+"
	}[kind];
}
function isAnyGroup({ type }) {
	return type === "CapturingGroup" || type === "Group" || type === "LookaroundAssertion";
}
function isDigitCharCode(value) {
	return value > 47 && value < 58;
}
function isLiteralHyphen({ type, value }) {
	return type === "Character" && value === 45;
}
var EmulatedRegExp = class _EmulatedRegExp extends RegExp {
	#captureMap = /* @__PURE__ */ new Map();
	#compiled = null;
	#pattern;
	#nameMap = null;
	#strategy = null;
	rawOptions = {};
	get source() {
		return this.#pattern || "(?:)";
	}
	constructor(pattern, flags, options) {
		const lazyCompile = !!options?.lazyCompile;
		if (pattern instanceof RegExp) {
			if (options) throw new Error("Cannot provide options when copying a regexp");
			const re$1 = pattern;
			super(re$1, flags);
			this.#pattern = re$1.source;
			if (re$1 instanceof _EmulatedRegExp) {
				this.#captureMap = re$1.#captureMap;
				this.#nameMap = re$1.#nameMap;
				this.#strategy = re$1.#strategy;
				this.rawOptions = re$1.rawOptions;
			}
		} else {
			const opts = {
				hiddenCaptures: [],
				strategy: null,
				transfers: [],
				...options
			};
			super(lazyCompile ? "" : pattern, flags);
			this.#pattern = pattern;
			this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);
			this.#strategy = opts.strategy;
			this.rawOptions = options ?? {};
		}
		if (!lazyCompile) this.#compiled = this;
	}
	exec(str) {
		if (!this.#compiled) {
			const { lazyCompile,...rest } = this.rawOptions;
			this.#compiled = new _EmulatedRegExp(this.#pattern, this.flags, rest);
		}
		const useLastIndex = this.global || this.sticky;
		const pos = this.lastIndex;
		if (this.#strategy === "clip_search" && useLastIndex && pos) {
			this.lastIndex = 0;
			const match = this.#execCore(str.slice(pos));
			if (match) {
				adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);
				this.lastIndex += pos;
			}
			return match;
		}
		return this.#execCore(str);
	}
	#execCore(str) {
		this.#compiled.lastIndex = this.lastIndex;
		const match = super.exec.call(this.#compiled, str);
		this.lastIndex = this.#compiled.lastIndex;
		if (!match || !this.#captureMap.size) return match;
		const matchCopy = [...match];
		match.length = 1;
		let indicesCopy;
		if (this.hasIndices) {
			indicesCopy = [...match.indices];
			match.indices.length = 1;
		}
		const mappedNums = [0];
		for (let i$1 = 1; i$1 < matchCopy.length; i$1++) {
			const { hidden, transferTo } = this.#captureMap.get(i$1) ?? {};
			if (hidden) mappedNums.push(null);
			else {
				mappedNums.push(match.length);
				match.push(matchCopy[i$1]);
				if (this.hasIndices) match.indices.push(indicesCopy[i$1]);
			}
			if (transferTo && matchCopy[i$1] !== void 0) {
				const to = mappedNums[transferTo];
				if (!to) throw new Error(`Invalid capture transfer to "${to}"`);
				match[to] = matchCopy[i$1];
				if (this.hasIndices) match.indices[to] = indicesCopy[i$1];
				if (match.groups) {
					if (!this.#nameMap) this.#nameMap = createNameMap(this.source);
					const name = this.#nameMap.get(transferTo);
					if (name) {
						match.groups[name] = matchCopy[i$1];
						if (this.hasIndices) match.indices.groups[name] = indicesCopy[i$1];
					}
				}
			}
		}
		return match;
	}
};
function adjustMatchDetailsForOffset(match, offset, input, hasIndices) {
	match.index += offset;
	match.input = input;
	if (hasIndices) {
		const indices = match.indices;
		for (let i$1 = 0; i$1 < indices.length; i$1++) {
			const arr = indices[i$1];
			if (arr) indices[i$1] = [arr[0] + offset, arr[1] + offset];
		}
		const groupIndices = indices.groups;
		if (groupIndices) Object.keys(groupIndices).forEach((key) => {
			const arr = groupIndices[key];
			if (arr) groupIndices[key] = [arr[0] + offset, arr[1] + offset];
		});
	}
}
function createCaptureMap(hiddenCaptures, transfers) {
	const captureMap = /* @__PURE__ */ new Map();
	for (const num of hiddenCaptures) captureMap.set(num, { hidden: true });
	for (const [to, from] of transfers) for (const num of from) getOrInsert(captureMap, num, {}).transferTo = to;
	return captureMap;
}
function createNameMap(pattern) {
	const re$1 = /(?<capture>\((?:\?<(?![=!])(?<name>[^>]+)>|(?!\?)))|\\?./gsu;
	const map = /* @__PURE__ */ new Map();
	let numCharClassesOpen = 0;
	let numCaptures = 0;
	let match;
	while (match = re$1.exec(pattern)) {
		const { 0: m$2, groups: { capture, name } } = match;
		if (m$2 === "[") numCharClassesOpen++;
		else if (!numCharClassesOpen) {
			if (capture) {
				numCaptures++;
				if (name) map.set(numCaptures, name);
			}
		} else if (m$2 === "]") numCharClassesOpen--;
	}
	return map;
}
function toRegExp(pattern, options) {
	const d$1 = toRegExpDetails(pattern, options);
	if (d$1.options) return new EmulatedRegExp(d$1.pattern, d$1.flags, d$1.options);
	return new RegExp(d$1.pattern, d$1.flags);
}
function toRegExpDetails(pattern, options) {
	const opts = getOptions(options);
	const onigurumaAst = J(pattern, {
		flags: opts.flags,
		normalizeUnknownPropertyNames: true,
		rules: {
			captureGroup: opts.rules.captureGroup,
			singleline: opts.rules.singleline
		},
		skipBackrefValidation: opts.rules.allowOrphanBackrefs,
		unicodePropertyMap: JsUnicodePropertyMap
	});
	const regexPlusAst = transform(onigurumaAst, {
		accuracy: opts.accuracy,
		asciiWordBoundaries: opts.rules.asciiWordBoundaries,
		avoidSubclass: opts.avoidSubclass,
		bestEffortTarget: opts.target
	});
	const generated = generate(regexPlusAst, opts);
	const recursionResult = recursion(generated.pattern, {
		captureTransfers: generated._captureTransfers,
		hiddenCaptures: generated._hiddenCaptures,
		mode: "external"
	});
	const possessiveResult = possessive(recursionResult.pattern);
	const atomicResult = atomic(possessiveResult.pattern, {
		captureTransfers: recursionResult.captureTransfers,
		hiddenCaptures: recursionResult.hiddenCaptures
	});
	const details = {
		pattern: atomicResult.pattern,
		flags: `${opts.hasIndices ? "d" : ""}${opts.global ? "g" : ""}${generated.flags}${generated.options.disable.v ? "u" : "v"}`
	};
	if (opts.avoidSubclass) {
		if (opts.lazyCompileLength !== Infinity) throw new Error("Lazy compilation requires subclass");
	} else {
		const hiddenCaptures = atomicResult.hiddenCaptures.sort((a$1, b$2) => a$1 - b$2);
		const transfers = Array.from(atomicResult.captureTransfers);
		const strategy = regexPlusAst._strategy;
		const lazyCompile = details.pattern.length >= opts.lazyCompileLength;
		if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) details.options = {
			...hiddenCaptures.length && { hiddenCaptures },
			...transfers.length && { transfers },
			...strategy && { strategy },
			...lazyCompile && { lazyCompile }
		};
	}
	return details;
}
const MAX = 4294967295;
var JavaScriptScanner = class {
	constructor(patterns, options = {}) {
		this.patterns = patterns;
		this.options = options;
		const { forgiving = false, cache, regexConstructor } = options;
		if (!regexConstructor) throw new Error("Option `regexConstructor` is not provided");
		this.regexps = patterns.map((p) => {
			if (typeof p !== "string") return p;
			const cached = cache?.get(p);
			if (cached) {
				if (cached instanceof RegExp) return cached;
				if (forgiving) return null;
				throw cached;
			}
			try {
				const regex = regexConstructor(p);
				cache?.set(p, regex);
				return regex;
			} catch (e) {
				cache?.set(p, e);
				if (forgiving) return null;
				throw e;
			}
		});
	}
	regexps;
	findNextMatchSync(string, startPosition, _options) {
		const str = typeof string === "string" ? string : string.content;
		const pending = [];
		function toResult(index, match, offset = 0) {
			return {
				index,
				captureIndices: match.indices.map((indice) => {
					if (indice == null) return {
						start: MAX,
						end: MAX,
						length: 0
					};
					return {
						start: indice[0] + offset,
						end: indice[1] + offset,
						length: indice[1] - indice[0]
					};
				})
			};
		}
		for (let i$1 = 0; i$1 < this.regexps.length; i$1++) {
			const regexp = this.regexps[i$1];
			if (!regexp) continue;
			try {
				regexp.lastIndex = startPosition;
				const match = regexp.exec(str);
				if (!match) continue;
				if (match.index === startPosition) return toResult(i$1, match, 0);
				pending.push([
					i$1,
					match,
					0
				]);
			} catch (e) {
				if (this.options.forgiving) continue;
				throw e;
			}
		}
		if (pending.length) {
			const minIndex = Math.min(...pending.map((m$2) => m$2[1].index));
			for (const [i$1, match, offset] of pending) if (match.index === minIndex) return toResult(i$1, match, offset);
		}
		return null;
	}
};
function defaultJavaScriptRegexConstructor(pattern, options) {
	return toRegExp(pattern, {
		global: true,
		hasIndices: true,
		lazyCompileLength: 3e3,
		rules: {
			allowOrphanBackrefs: true,
			asciiWordBoundaries: true,
			captureGroup: true,
			recursionLimit: 5,
			singleline: true
		},
		...options
	});
}
function createJavaScriptRegexEngine(options = {}) {
	const _options = Object.assign({
		target: "auto",
		cache: /* @__PURE__ */ new Map()
	}, options);
	_options.regexConstructor ||= (pattern) => defaultJavaScriptRegexConstructor(pattern, { target: _options.target });
	return {
		createScanner(patterns) {
			return new JavaScriptScanner(patterns, _options);
		},
		createString(s$1) {
			return { content: s$1 };
		}
	};
}
export { ShikiError, addClassToHast, applyColorReplacements, bundledLanguages, bundledLanguagesAlias, bundledLanguagesBase, bundledLanguagesInfo, bundledThemes, bundledThemesInfo, codeToHast, codeToHtml, codeToTokens, codeToTokensBase, codeToTokensWithThemes, createCssVariablesTheme, createHighlighter, createHighlighterCore, createHighlighterCoreSync, createJavaScriptRegexEngine, createOnigurumaEngine, createPositionConverter, createShikiInternal, createShikiInternalSync, createSingletonShorthands, createdBundledHighlighter, defaultJavaScriptRegexConstructor, enableDeprecationWarnings, flatTokenVariants, getLastGrammarState, getSingletonHighlighter, getSingletonHighlighterCore, getTokenStyleObject, guessEmbeddedLanguages, hastToHtml, isNoneTheme, isPlainLang, isSpecialLang, isSpecialTheme, loadWasm, makeSingletonHighlighter, makeSingletonHighlighterCore, normalizeGetter, normalizeTheme, resolveColorReplacements, splitLines, splitToken, splitTokens, stringifyTokenStyle, toArray, tokenizeAnsiWithTheme, tokenizeWithTheme, tokensToHast, transformerDecorations, warnDeprecated };
